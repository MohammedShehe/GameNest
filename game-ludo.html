<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ludo Game - GameNest</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* CSS Variables */
        :root {
            --primary-color: #6c5ce7;
            --secondary-color: #a29bfe;
            --accent-color: #fd79a8;
            --accent-glow: rgba(253, 121, 168, 0.6);
            --dark-color: #2d3436;
            --light-color: #dfe6e9;
            --success-color: #00b894;
            --success-glow: rgba(0, 184, 148, 0.6);
            --warning-color: #fdcb6e;
            --danger-color: #e17055;
            --card-bg: rgba(255, 255, 255, 0.1);
            --card-glow: rgba(255, 255, 255, 0.15);
            --card-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            --border-radius: 20px;
            --transition: all 0.3s ease;
            --game-bg: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            --neon-glow: 0 0 10px currentColor, 0 0 20px currentColor, 0 0 30px currentColor;
            
            /* Ludo Colors */
            --red-color: #e74c3c;
            --red-dark: #c0392b;
            --blue-color: #3498db;
            --blue-dark: #2980b9;
            --yellow-color: #f1c40f;
            --yellow-dark: #d4ac0d;
            --green-color: #2ecc71;
            --green-dark: #27ae60;
        }

        /* Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800;900&display=swap');

        body {
            font-family: 'Poppins', sans-serif;
            background: var(--game-bg);
            color: white;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 107, 107, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(77, 201, 208, 0.05) 0%, transparent 50%);
            z-index: -1;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Fixed Navigation Buttons */
        .fixed-back-btn {
            position: fixed;
            top: 30px;
            left: 30px;
            width: 55px;
            height: 55px;
            border-radius: 50%;
            background: var(--card-bg);
            border: 1px solid var(--card-glow);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.3rem;
            cursor: pointer;
            transition: var(--transition);
            backdrop-filter: blur(15px);
            box-shadow: var(--card-shadow);
            z-index: 1000;
        }

        .fixed-exit-btn {
            position: fixed;
            top: 30px;
            right: 30px;
            width: 55px;
            height: 55px;
            border-radius: 50%;
            background: var(--card-bg);
            border: 1px solid var(--card-glow);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.3rem;
            cursor: pointer;
            transition: var(--transition);
            backdrop-filter: blur(15px);
            box-shadow: var(--card-shadow);
            z-index: 1000;
        }

        .fixed-back-btn::before, .fixed-exit-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: 0.5s;
        }

        .fixed-back-btn:hover::before, .fixed-exit-btn:hover::before {
            left: 100%;
        }

        .fixed-back-btn:hover, .fixed-exit-btn:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            background: rgba(255, 255, 255, 0.15);
        }

        /* Header Styles */
        .page-header {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px 0;
            margin-bottom: 30px;
        }

        .header-center h1 {
            font-size: 2.2rem;
            font-weight: 800;
            text-align: center;
            background: linear-gradient(to right, #a29bfe, #fd79a8, #00b894);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            letter-spacing: 1px;
            position: relative;
            padding-bottom: 10px;
        }

        .header-center h1::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 3px;
            background: linear-gradient(to right, #a29bfe, #fd79a8, #00b894);
            border-radius: 3px;
        }

        /* Ludo Game Specific Styles */
        .ludo-game-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
        }

        .game-header {
            text-align: center;
            margin-bottom: 25px;
            width: 100%;
        }

        .game-title {
            font-size: 3rem;
            margin-bottom: 15px;
            background: linear-gradient(to right, #00b894, #55efc4, #81ecec);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            font-weight: 900;
            letter-spacing: 1px;
            position: relative;
            display: inline-block;
        }

        .game-title::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 150px;
            height: 4px;
            background: linear-gradient(to right, #00b894, #55efc4, #81ecec);
            border-radius: 4px;
            box-shadow: 0 0 10px rgba(0, 184, 148, 0.5);
        }

        .game-setup {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 25px;
            padding: 20px;
            background: var(--card-bg);
            backdrop-filter: blur(15px);
            border-radius: var(--border-radius);
            box-shadow: var(--card-shadow);
            border: 1px solid var(--card-glow);
            width: 100%;
            max-width: 500px;
        }

        .setup-options {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
        }

        .option-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex: 1;
            min-width: 200px;
        }

        .option-group label {
            font-weight: bold;
            color: var(--light-color);
        }

        .option-select {
            padding: 10px 15px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            font-size: 16px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            cursor: pointer;
            transition: var(--transition);
        }

        .option-select:focus {
            border-color: var(--primary-color);
            outline: none;
        }

        .start-btn {
            padding: 12px 25px;
            font-size: 18px;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, var(--success-color), #55efc4);
            color: white;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            margin: 0 auto;
        }

        .start-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 184, 148, 0.4);
        }

        .game-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding: 20px;
            background: var(--card-bg);
            backdrop-filter: blur(15px);
            border-radius: var(--border-radius);
            box-shadow: var(--card-shadow);
            border: 1px solid var(--card-glow);
            width: 100%;
            max-width: 800px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .dice-container {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .dice {
            width: 70px;
            height: 70px;
            background: white;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            font-weight: bold;
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: var(--transition);
            position: relative;
            overflow: hidden;
            color: var(--dark-color);
        }

        .dice::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(255,255,255,0.3), rgba(255,255,255,0.1));
            border-radius: 15px;
        }

        .dice:hover {
            transform: scale(1.08);
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
        }

        .dice.rolling {
            animation: roll 0.5s ease-in-out infinite;
        }

        @keyframes roll {
            0% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(90deg) scale(1.1); }
            50% { transform: rotate(180deg) scale(1); }
            75% { transform: rotate(270deg) scale(1.1); }
            100% { transform: rotate(360deg) scale(1); }
        }

        .roll-btn {
            padding: 12px 25px;
            font-size: 18px;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .roll-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(108, 92, 231, 0.4);
        }

        .roll-btn:disabled {
            background: #636e72;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .game-status {
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            margin: 0;
            padding: 12px 20px;
            border-radius: 10px;
            background: var(--card-bg);
            box-shadow: var(--card-shadow);
            flex: 1;
            min-width: 250px;
            border: 1px solid var(--card-glow);
        }

        .game-board-container {
            position: relative;
            margin-bottom: 25px;
            width: 100%;
            display: flex;
            justify-content: center;
        }

        .ludo-board {
            width: 100%;
            max-width: 500px;
            aspect-ratio: 1;
            display: grid;
            grid-template-columns: repeat(15, 1fr);
            grid-template-rows: repeat(15, 1fr);
            gap: 2px;
            background: #2c3e50;
            border: 6px solid #34495e;
            border-radius: 15px;
            padding: 6px;
            box-shadow: 
                inset 0 0 20px rgba(0,0,0,0.3),
                0 15px 35px rgba(0, 0, 0, 0.4);
        }

        .cell {
            background: white;
            border: 1px solid #bdc3c7;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            min-height: 25px;
            border-radius: 5px;
            transition: var(--transition);
        }

        /* Home areas */
        .home-red { 
            background: linear-gradient(135deg, var(--red-color), var(--red-dark)) !important; 
            border-radius: 8px;
        }
        .home-blue { 
            background: linear-gradient(135deg, var(--blue-color), var(--blue-dark)) !important; 
            border-radius: 8px;
        }
        .home-yellow { 
            background: linear-gradient(135deg, var(--yellow-color), var(--yellow-dark)) !important; 
            border-radius: 8px;
        }
        .home-green { 
            background: linear-gradient(135deg, var(--green-color), var(--green-dark)) !important; 
            border-radius: 8px;
        }

        /* Safe zones */
        .safe-red { 
            background: rgba(231, 76, 60, 0.2) !important; 
            border: 2px dashed var(--red-color);
        }
        .safe-blue { 
            background: rgba(52, 152, 219, 0.2) !important; 
            border: 2px dashed var(--blue-color);
        }
        .safe-yellow { 
            background: rgba(241, 196, 15, 0.2) !important; 
            border: 2px dashed var(--yellow-color);
        }
        .safe-green { 
            background: rgba(46, 204, 113, 0.2) !important; 
            border: 2px dashed var(--green-color);
        }

        /* Path cells */
        .path { 
            background: rgba(236, 240, 241, 0.8) !important; 
        }
        .start-red { 
            background: rgba(231, 76, 60, 0.3) !important; 
            border: 2px solid var(--red-color);
        }
        .start-blue { 
            background: rgba(52, 152, 219, 0.3) !important; 
            border: 2px solid var(--blue-color);
        }
        .start-yellow { 
            background: rgba(241, 196, 15, 0.3) !important; 
            border: 2px solid var(--yellow-color);
        }
        .start-green { 
            background: rgba(46, 204, 113, 0.3) !important; 
            border: 2px solid var(--green-color);
        }

        /* Center */
        .center {
            background: linear-gradient(45deg, var(--red-color) 25%, var(--blue-color) 25%, var(--blue-color) 50%, var(--yellow-color) 50%, var(--yellow-color) 75%, var(--green-color) 75%) !important;
            border-radius: 10px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2);
        }

        /* Tokens */
        .token {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
            cursor: pointer;
            transition: var(--transition);
            position: absolute;
            z-index: 10;
        }

        .token:hover {
            transform: scale(1.2);
            box-shadow: 0 5px 10px rgba(0,0,0,0.4);
        }

        .token.token-red { 
            background: var(--red-dark); 
            border-color: #fff;
        }
        .token.token-blue { 
            background: var(--blue-dark); 
            border-color: #fff;
        }
        .token.token-yellow { 
            background: var(--yellow-dark); 
            border-color: #fff;
        }
        .token.token-green { 
            background: var(--green-dark); 
            border-color: #fff;
        }

        /* Multiple tokens in same cell */
        .token-1 { top: 2px; left: 2px; }
        .token-2 { top: 2px; right: 2px; }
        .token-3 { bottom: 2px; left: 2px; }
        .token-4 { bottom: 2px; right: 2px; }

        .highlight-move {
            animation: pulse 1.5s infinite;
            box-shadow: 0 0 0 5px rgba(255, 255, 255, 0.8);
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(52, 152, 219, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(52, 152, 219, 0); }
            100% { box-shadow: 0 0 0 0 rgba(52, 152, 219, 0); }
        }

        .player-info {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 20px;
            width: 100%;
            max-width: 800px;
        }

        .player {
            text-align: center;
            padding: 15px;
            border-radius: 15px;
            color: white;
            font-weight: bold;
            box-shadow: var(--card-shadow);
            transition: var(--transition);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            background: var(--card-bg);
            backdrop-filter: blur(15px);
            border: 1px solid var(--card-glow);
        }

        .player.active {
            transform: scale(1.05);
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
            border: 3px solid rgba(255, 255, 255, 0.5);
        }

        .player-red { 
            border-left: 5px solid var(--red-color);
        }
        .player-blue { 
            border-left: 5px solid var(--blue-color);
        }
        .player-yellow { 
            border-left: 5px solid var(--yellow-color);
        }
        .player-green { 
            border-left: 5px solid var(--green-color);
        }

        .player-name {
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .player-tokens {
            display: flex;
            justify-content: center;
            gap: 8px;
        }

        .player-token {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid white;
            transition: var(--transition);
        }

        .player-token.completed {
            opacity: 0.5;
            transform: scale(0.8);
        }

        .player-token.token-red { background: var(--red-dark); }
        .player-token.token-blue { background: var(--blue-dark); }
        .player-token.token-yellow { background: var(--yellow-dark); }
        .player-token.token-green { background: var(--green-dark); }

        .winning-message {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
            backdrop-filter: blur(10px);
        }

        .winning-message.show {
            opacity: 1;
            pointer-events: all;
        }

        .winning-content {
            background: var(--card-bg);
            backdrop-filter: blur(20px);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 500px;
            width: 90%;
            box-shadow: 
                0 20px 50px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            transform: scale(0.9) translateY(20px);
            transition: transform 0.4s ease, opacity 0.4s ease;
            border: 1px solid var(--card-glow);
            position: relative;
            overflow: hidden;
        }

        .winning-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background: linear-gradient(to right, #fd79a8, #e17055);
        }

        .winning-message.show .winning-content {
            transform: scale(1) translateY(0);
        }

        .winning-content h2 {
            font-size: 2.2rem;
            margin-bottom: 15px;
            color: var(--accent-color);
            text-shadow: 0 0 10px var(--accent-glow);
            font-weight: 800;
        }

        .winning-content p {
            font-size: 1.2rem;
            margin-bottom: 25px;
            color: var(--light-color);
        }

        .new-game-btn {
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, var(--success-color), #55efc4);
            color: white;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 0 auto;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .new-game-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 184, 148, 0.4);
        }

        .game-rules {
            margin-top: 25px;
            padding: 20px;
            background: var(--card-bg);
            backdrop-filter: blur(15px);
            border-radius: var(--border-radius);
            box-shadow: var(--card-shadow);
            border: 1px solid var(--card-glow);
            width: 100%;
            max-width: 800px;
        }

        .game-rules h3 {
            margin-bottom: 15px;
            color: var(--light-color);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .rules-list {
            list-style-type: none;
            padding-left: 0;
        }

        .rules-list li {
            margin-bottom: 10px;
            padding-left: 25px;
            position: relative;
        }

        .rules-list li:before {
            content: 'â€¢';
            color: var(--primary-color);
            font-weight: bold;
            position: absolute;
            left: 10px;
        }

        .ai-thinking {
            display: none;
            text-align: center;
            padding: 10px;
            background: var(--card-bg);
            border-radius: 10px;
            margin-bottom: 15px;
            width: 100%;
            max-width: 800px;
            border: 1px solid var(--card-glow);
        }

        .ai-thinking.show {
            display: block;
        }

        /* Bot Assistant Styles */
        .bot-container {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 1000;
        }

        .bot-toggle {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            border: none;
            color: white;
            font-size: 2rem;
            cursor: pointer;
            box-shadow: 
                0 6px 25px rgba(108, 92, 231, 0.5),
                0 0 15px rgba(108, 92, 231, 0.6);
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
            animation: pulse 2s infinite;
            position: relative;
            overflow: hidden;
        }

        .bot-toggle::before {
            content: '';
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            border-radius: 50%;
            z-index: -1;
            opacity: 0.4;
            filter: blur(15px);
        }

        .bot-toggle:hover {
            transform: scale(1.1) rotate(5deg);
            box-shadow: 
                0 8px 30px rgba(108, 92, 231, 0.7),
                0 0 20px rgba(108, 92, 231, 0.8);
        }

        .bot-assistant {
            position: absolute;
            bottom: 90px;
            right: 0;
            width: 350px;
            background: var(--card-bg);
            backdrop-filter: blur(20px);
            border-radius: var(--border-radius);
            box-shadow: var(--card-shadow);
            overflow: hidden;
            transform: translateY(20px) scale(0.95);
            opacity: 0;
            visibility: hidden;
            transition: var(--transition);
            border: 1px solid var(--card-glow);
        }

        .bot-assistant.active {
            transform: translateY(0) scale(1);
            opacity: 1;
            visibility: visible;
        }

        .bot-header {
            padding: 18px 25px;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--card-glow);
        }

        .bot-header h3 {
            font-size: 1.3rem;
            font-weight: 700;
        }

        .bot-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.3rem;
            cursor: pointer;
            transition: var(--transition);
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .bot-close:hover {
            transform: rotate(90deg);
            background: rgba(255, 255, 255, 0.1);
        }

        .bot-content {
            padding: 25px;
        }

        .bot-messages {
            margin-bottom: 25px;
            max-height: 220px;
            overflow-y: auto;
            padding-right: 10px;
        }

        .bot-messages::-webkit-scrollbar {
            width: 5px;
        }

        .bot-messages::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
        }

        .bot-message {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px 18px;
            border-radius: 15px;
            margin-bottom: 12px;
            border-left: 3px solid var(--success-color);
        }

        .bot-message p {
            margin: 0;
            line-height: 1.5;
            font-size: 0.95rem;
        }

        .bot-questions {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .bot-question {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            padding: 14px 18px;
            border-radius: 12px;
            color: white;
            text-align: left;
            cursor: pointer;
            transition: var(--transition);
            font-size: 0.95rem;
            width: 100%;
            border: 1px solid transparent;
        }

        .bot-question:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(5px);
            border-color: rgba(255, 255, 255, 0.1);
        }

        /* Music Toggle Styles */
        .music-toggle {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: var(--card-bg);
            border: 1px solid var(--card-glow);
            color: white;
            font-size: 1.4rem;
            cursor: pointer;
            backdrop-filter: blur(15px);
            box-shadow: var(--card-shadow);
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1001;
        }

        .music-toggle::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: 0.5s;
        }

        .music-toggle:hover::before {
            left: 100%;
        }

        .music-toggle:hover {
            transform: scale(1.1);
            background: rgba(255, 255, 255, 0.15);
        }

        /* Music Playing Animation */
        .music-toggle.playing {
            background: var(--accent-color);
            animation: musicPulse 2s infinite;
        }

        /* Typing animation */
        .typing-cursor {
            display: inline-block;
            width: 3px;
            height: 1em;
            background-color: white;
            margin-left: 2px;
            animation: blink 1s infinite;
            vertical-align: middle;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        /* Animations */
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 
                    0 6px 25px rgba(108, 92, 231, 0.5),
                    0 0 15px rgba(108, 92, 231, 0.6);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 
                    0 8px 30px rgba(108, 92, 231, 0.7),
                    0 0 20px rgba(108, 92, 231, 0.8);
            }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        @keyframes musicPulse {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(253, 121, 168, 0.7);
            }
            50% {
                box-shadow: 0 0 0 10px rgba(253, 121, 168, 0);
            }
        }

        /* Particle effect for background */
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            overflow: hidden;
        }
        
        .particle {
            position: absolute;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            animation: float 15s infinite linear;
        }

        /* Responsive adjustments */
        @media (max-width: 992px) {
            .game-title {
                font-size: 2.8rem;
            }
            
            .player-info {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .game-title {
                font-size: 2.2rem;
            }
            
            .game-controls {
                flex-direction: column;
                align-items: center;
            }
            
            .dice-container {
                width: 100%;
                justify-content: center;
            }
            
            .game-status {
                width: 100%;
            }
            
            .token {
                width: 16px;
                height: 16px;
            }
            
            .player {
                padding: 12px;
            }
            
            .player-name {
                font-size: 1.1rem;
            }

            .dice {
                width: 60px;
                height: 60px;
                font-size: 24px;
            }

            .roll-btn {
                padding: 10px 20px;
                font-size: 16px;
            }

            .bot-container {
                bottom: 20px;
                right: 20px;
            }
            
            .bot-assistant {
                width: 300px;
            }
            
            .winning-content {
                padding: 25px;
            }
            
            .fixed-back-btn, .fixed-exit-btn {
                top: 20px;
                width: 50px;
                height: 50px;
                font-size: 1.2rem;
            }
            
            .fixed-back-btn {
                left: 20px;
            }
            
            .fixed-exit-btn {
                right: 20px;
            }
            
            .music-toggle {
                bottom: 20px;
                left: 20px;
                width: 55px;
                height: 55px;
            }
        }

        @media (max-width: 576px) {
            .ludo-game-container {
                padding: 5px;
            }
            
            .game-title {
                font-size: 1.8rem;
            }
            
            .game-setup, .game-controls, .game-rules {
                padding: 15px;
            }
            
            .player {
                min-width: auto;
                padding: 10px;
                font-size: 0.9rem;
            }
            
            .player-token {
                width: 12px;
                height: 12px;
            }

            .game-controls {
                padding: 15px;
            }

            .dice {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }

            .roll-btn {
                padding: 8px 16px;
                font-size: 14px;
            }
            
            .game-status {
                font-size: 16px;
                padding: 10px 15px;
            }
            
            .winning-content {
                padding: 20px;
            }
            
            .winning-content h2 {
                font-size: 1.8rem;
            }
            
            .bot-container {
                bottom: 15px;
                right: 15px;
            }
            
            .bot-assistant {
                width: 280px;
            }
            
            .music-toggle {
                bottom: 15px;
                left: 15px;
                width: 55px;
                height: 55px;
            }
            
            .fixed-back-btn, .fixed-exit-btn {
                top: 15px;
                width: 45px;
                height: 45px;
                font-size: 1.1rem;
            }
            
            .fixed-back-btn {
                left: 15px;
            }
            
            .fixed-exit-btn {
                right: 15px;
            }
        }

        @media (max-width: 400px) {
            .game-title {
                font-size: 1.6rem;
            }
            
            .dice-container {
                flex-direction: column;
                gap: 10px;
            }
            
            .bot-assistant {
                width: 260px;
            }
            
            .fixed-back-btn, .fixed-exit-btn {
                width: 40px;
                height: 40px;
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <!-- Background Particles -->
    <div class="particles" id="particles"></div>
    
    <!-- Fixed Navigation Buttons -->
    <button class="fixed-back-btn" id="btnBack">
        <i class="fas fa-arrow-left"></i>
    </button>
    
    <button class="fixed-exit-btn" id="btnExit">
        <i class="fas fa-times"></i>
    </button>
    
    <div class="container">
        <!-- Header with title only -->
        <header class="page-header">
            <div class="header-center">
                <h1>Ludo Game - Milah Special</h1>
            </div>
        </header>

        <!-- Ludo Game Content -->
        <main class="ludo-game-container">
            <div class="game-header">
                <h2 class="game-title">Ludo Master</h2>
            </div>
            
            <div class="game-setup" id="gameSetup">
                <div class="setup-options">
                    <div class="option-group">
                        <label for="gameMode">Game Mode</label>
                        <select class="option-select" id="gameMode">
                            <option value="multiplayer">Multiplayer</option>
                            <option value="ai">Play with AI</option>
                        </select>
                    </div>
                    <div class="option-group">
                        <label for="playerCount">Number of Players</label>
                        <select class="option-select" id="playerCount">
                            <option value="2">2 Players</option>
                            <option value="4" selected>4 Players</option>
                        </select>
                    </div>
                </div>
                <button class="start-btn" id="startBtn">
                    <i class="fas fa-play"></i> Start Game
                </button>
            </div>
            
            <div class="ai-thinking" id="aiThinking">
                <i class="fas fa-robot"></i> AI is thinking...
            </div>
            
            <div class="game-controls" id="gameControls" style="display: none;">
                <div class="dice-container">
                    <div class="dice" id="dice">1</div>
                    <button class="roll-btn" id="rollBtn">
                        <i class="fas fa-dice"></i> Roll Dice
                    </button>
                </div>
                <div class="game-status" id="gameStatus">Red Player's Turn</div>
            </div>
            
            <div class="game-board-container" id="gameBoardContainer" style="display: none;">
                <div class="ludo-board" id="ludoBoard">
                    <!-- Board will be generated by JavaScript -->
                </div>
            </div>

            <div class="player-info" id="playerInfo" style="display: none;">
                <!-- Player info will be generated by JavaScript -->
            </div>
            
            <div class="game-rules" id="gameRules" style="display: none;">
                <h3><i class="fas fa-info-circle"></i> Game Rules</h3>
                <ul class="rules-list">
                    <li>Roll a 6 to move a token out of your home area</li>
                    <li>Move your tokens around the board clockwise</li>
                    <li>Land on an opponent's token to send it back to their home</li>
                    <li>First player to get all tokens to the center wins</li>
                    <li>Three consecutive 6s will send all your tokens back home</li>
                </ul>
            </div>
        </main>

        <!-- Winning Message Modal -->
        <div class="winning-message" id="winningMessage">
            <div class="winning-content">
                <h2 id="winnerText">Red Player Wins!</h2>
                <p>Congratulations on winning the game!</p>
                <button class="new-game-btn" id="newGameBtn">
                    <i class="fas fa-redo"></i> Play Again
                </button>
            </div>
        </div>

        <!-- Bot Assistant -->
        <div class="bot-container">
            <button class="bot-toggle" id="botToggle">
                <i class="fas fa-question-circle"></i>
            </button>
            <div class="bot-assistant" id="botAssistant">
                <div class="bot-header">
                    <h3>MO11 - <a href="https://www.instagram.com/mo_little11?igsh=MTZsdWhpeXg5ZGttYQ%3D%3D&utm_source=qr" style="color: #fd79a8; text-decoration: none;">#1011</a></h3>
                    <button class="bot-close" id="botClose">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="bot-content">
                    <div class="bot-messages">
                        <div class="bot-message">
                            <p>Need help with the Ludo game? I can assist you!</p>
                        </div>
                    </div>
                    <div class="bot-questions">
                        <button class="bot-question" data-question="ludo-rules">
                            <span>How to play Ludo?</span>
                        </button>
                        <button class="bot-question" data-question="ludo-tips">
                            <span>Tips for winning</span>
                        </button>
                        <button class="bot-question" data-question="ludo-strategy">
                            <span>Best strategies</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Background Music -->
        <audio id="backgroundMusic" loop>
            <!-- Using placeholder audio sources that work in browsers -->
            <source src="assets/audio/background3.mp3" type="audio/mpeg">
            Your browser does not support the audio element.
        </audio>
        <button class="music-toggle" id="musicToggle">
            <i class="fas fa-volume-up"></i>
        </button>

        <!-- Game Sounds -->
        <audio id="diceRollSound" preload="auto">
            <source src="assets/audio/dice.mp3" type="audio/mpeg">
        </audio>
        <audio id="tokenMoveSound" preload="auto">
            <source src="assets/audio/checkers-move.mp3" type="audio/mpeg">
        </audio>
        <audio id="winSound" preload="auto">
            <source src="assets/audio/king.mp3" type="audio/mpeg">
        </audio>
    </div>

    <script>
        // LUDO GAME - WITH ALL FEATURES
        document.addEventListener('DOMContentLoaded', function() {
            // ===== GAME VARIABLES =====
            const gameSetup = document.getElementById('gameSetup');
            const gameControls = document.getElementById('gameControls');
            const gameBoardContainer = document.getElementById('gameBoardContainer');
            const playerInfo = document.getElementById('playerInfo');
            const gameRules = document.getElementById('gameRules');
            const aiThinking = document.getElementById('aiThinking');
            const winningMessage = document.getElementById('winningMessage');
            
            // Game state
            let board = [];
            let allPlayers = ['red', 'blue', 'yellow', 'green'];
            let players = [];
            let currentPlayerIndex = 0;
            let diceValue = 1;
            let gameActive = false;
            let consecutiveSixes = 0;
            let gameMode = 'multiplayer';
            let playerCount = 4;
            let tokens = {};
            let paths = {};
            let finalPaths = {};
            let startPositions = {};
            let aiThinkingTimeout;
            
            // ===== PARTICLE BACKGROUND =====
            function createParticles() {
                const particlesContainer = document.getElementById('particles');
                const particleCount = 30;
                
                for (let i = 0; i < particleCount; i++) {
                    const particle = document.createElement('div');
                    particle.classList.add('particle');
                    
                    // Random properties
                    const size = Math.random() * 5 + 2;
                    const posX = Math.random() * 100;
                    const posY = Math.random() * 100;
                    const opacity = Math.random() * 0.1 + 0.05;
                    const animationDuration = Math.random() * 30 + 20;
                    const animationDelay = Math.random() * 10;
                    
                    particle.style.width = `${size}px`;
                    particle.style.height = `${size}px`;
                    particle.style.left = `${posX}%`;
                    particle.style.top = `${posY}%`;
                    particle.style.opacity = opacity;
                    particle.style.animationDuration = `${animationDuration}s`;
                    particle.style.animationDelay = `${animationDelay}s`;
                    
                    particlesContainer.appendChild(particle);
                }
            }
            
            // ===== AUTO-PLAY MUSIC FUNCTIONALITY =====
            function initializeMusic() {
                const backgroundMusic = document.getElementById('backgroundMusic');
                const musicToggle = document.getElementById('musicToggle');
                
                if (backgroundMusic) {
                    // Set volume to 50% for better user experience
                    backgroundMusic.volume = 0.5;
                    
                    // Auto-play music when page loads
                    function autoPlayMusic() {
                        const playPromise = backgroundMusic.play();
                        
                        if (playPromise !== undefined) {
                            playPromise.then(() => {
                                // Music started successfully
                                musicToggle.classList.add('playing');
                                musicToggle.innerHTML = '<i class="fas fa-volume-up"></i>';
                                console.log('Background music started automatically');
                            }).catch(error => {
                                // Auto-play was prevented, show muted state
                                console.log('Auto-play prevented:', error);
                                musicToggle.innerHTML = '<i class="fas fa-volume-mute"></i>';
                                
                                // Add click event to start music on user interaction
                                document.body.addEventListener('click', function startMusicOnClick() {
                                    backgroundMusic.play().then(() => {
                                        musicToggle.classList.add('playing');
                                        musicToggle.innerHTML = '<i class="fas fa-volume-up"></i>';
                                    }).catch(e => {
                                        console.log('Manual play also failed:', e);
                                    });
                                    // Remove the event listener after first click
                                    document.body.removeEventListener('click', startMusicOnClick);
                                }, { once: true });
                            });
                        }
                    }
                    
                    // Start auto-play
                    autoPlayMusic();
                }
            }
            
            // ===== GAME FUNCTIONS =====
            function initializeGameElements() {
                // Initialize tokens for all possible players
                for (const color of allPlayers) {
                    tokens[color] = [
                        { id: 1, position: 'home', homePosition: getHomePosition(color, 1), pathIndex: -1, completed: false },
                        { id: 2, position: 'home', homePosition: getHomePosition(color, 2), pathIndex: -1, completed: false },
                        { id: 3, position: 'home', homePosition: getHomePosition(color, 3), pathIndex: -1, completed: false },
                        { id: 4, position: 'home', homePosition: getHomePosition(color, 4), pathIndex: -1, completed: false }
                    ];
                }

                // Define paths for each player
                for (const color of allPlayers) {
                    paths[color] = generatePath(color);
                    finalPaths[color] = generateFinalPath(color);
                }

                // Define starting positions for each player
                startPositions = {
                    red: { row: 6, col: 1 },
                    blue: { row: 1, col: 8 },
                    yellow: { row: 8, col: 13 },
                    green: { row: 13, col: 6 }
                };
            }

            function getHomePosition(color, tokenId) {
                // Define home positions for each token based on color
                const positions = {
                    red: [
                        { row: 1, col: 1 },
                        { row: 1, col: 3 },
                        { row: 3, col: 1 },
                        { row: 3, col: 3 }
                    ],
                    blue: [
                        { row: 1, col: 11 },
                        { row: 1, col: 13 },
                        { row: 3, col: 11 },
                        { row: 3, col: 13 }
                    ],
                    yellow: [
                        { row: 11, col: 11 },
                        { row: 11, col: 13 },
                        { row: 13, col: 11 },
                        { row: 13, col: 13 }
                    ],
                    green: [
                        { row: 11, col: 1 },
                        { row: 11, col: 3 },
                        { row: 13, col: 1 },
                        { row: 13, col: 3 }
                    ]
                };
                
                return positions[color][tokenId - 1];
            }

            function startGame() {
                gameMode = document.getElementById('gameMode').value;
                playerCount = parseInt(document.getElementById('playerCount').value);
                
                // Set active players based on player count
                if (playerCount === 2) {
                    players = ['red', 'blue'];
                } else {
                    players = ['red', 'blue', 'yellow', 'green'];
                }
                
                // Hide setup and show game elements
                gameSetup.style.display = 'none';
                gameControls.style.display = 'flex';
                gameBoardContainer.style.display = 'block';
                playerInfo.style.display = 'grid';
                gameRules.style.display = 'block';
                
                // Create player info elements
                createPlayerInfo();
                
                currentPlayerIndex = 0;
                diceValue = 1;
                gameActive = true;
                consecutiveSixes = 0;
                
                // Reset all tokens for active players
                for (const color of players) {
                    for (const token of tokens[color]) {
                        token.position = 'home';
                        token.pathIndex = -1;
                        token.completed = false;
                    }
                }
                
                initializeBoard();
                renderBoard();
                placeTokens();
                updateGameStatus();
                
                // Enable token clicks for current player
                enableCurrentPlayerTokens();
                
                // If it's an AI player's turn, automatically roll the dice
                if (gameMode === 'ai' && getCurrentPlayer() !== 'red') {
                    setTimeout(() => {
                        rollDice();
                    }, 500);
                }
            }

            function createPlayerInfo() {
                playerInfo.innerHTML = '';
                
                for (const color of players) {
                    const playerElement = document.createElement('div');
                    playerElement.className = `player player-${color}`;
                    playerElement.id = `player${color.charAt(0).toUpperCase() + color.slice(1)}`;
                    
                    const playerName = document.createElement('div');
                    playerName.className = 'player-name';
                    
                    // Add AI indicator if applicable
                    if (gameMode === 'ai' && color !== 'red') {
                        playerName.innerHTML = `<i class="fas fa-robot"></i> ${color.charAt(0).toUpperCase() + color.slice(1)} AI`;
                    } else {
                        playerName.innerHTML = `<i class="fas fa-flag"></i> ${color.charAt(0).toUpperCase() + color.slice(1)} Player`;
                    }
                    
                    const playerTokens = document.createElement('div');
                    playerTokens.className = 'player-tokens';
                    playerTokens.id = `${color}Tokens`;
                    
                    for (let i = 0; i < 4; i++) {
                        const tokenElement = document.createElement('div');
                        tokenElement.className = `player-token token-${color}`;
                        playerTokens.appendChild(tokenElement);
                    }
                    
                    playerElement.appendChild(playerName);
                    playerElement.appendChild(playerTokens);
                    playerInfo.appendChild(playerElement);
                }
            }

            function initializeBoard() {
                // Create 15x15 grid
                for (let row = 0; row < 15; row++) {
                    board[row] = [];
                    for (let col = 0; col < 15; col++) {
                        board[row][col] = getCellType(row, col);
                    }
                }
            }

            function getCellType(row, col) {
                // Home areas
                if (row >= 0 && row <= 4 && col >= 0 && col <= 4) return 'home-red';
                if (row >= 0 && row <= 4 && col >= 10 && col <= 14) return 'home-blue';
                if (row >= 10 && row <= 14 && col >= 10 && col <= 14) return 'home-yellow';
                if (row >= 10 && row <= 14 && col >= 0 && col <= 4) return 'home-green';

                // Center
                if (row >= 6 && row <= 8 && col >= 6 && col <= 8) return 'center';

                // Horizontal main paths
                if (row === 6) {
                    if (col === 1) return 'start-red';
                    if ((col >= 0 && col <= 5) || (col >= 9 && col <= 14)) return 'path';
                }
                if (row === 8) {
                    if (col === 13) return 'start-yellow';
                    if ((col >= 0 && col <= 5) || (col >= 9 && col <= 14)) return 'path';
                }

                // Vertical main paths
                if (col === 8) {
                    if (row === 1) return 'start-blue';
                    if ((row >= 0 && row <= 5) || (row >= 9 && row <= 14)) return 'path';
                }
                if (col === 6) {
                    if (row === 13) return 'start-green';
                    if (row >= 9 && row <= 14) return 'path';
                }

                // Safe zones (final paths to center)
                if (row === 7 && col >= 1 && col <= 5) return 'safe-red';
                if (col === 7 && row >= 1 && row <= 5) return 'safe-blue';
                if (row === 7 && col >= 9 && col <= 13) return 'safe-yellow';
                if (col === 7 && row >= 9 && row <= 13) return 'safe-green';

                return 'path';
            }

            function generatePath(color) {
                // Generate the main circular path positions for each color (clockwise)
                const path = [];

                if (color === 'red') {
                    // Red path: Start at (6,1) and move clockwise
                    path.push({ row: 6, col: 1 }); // Start
                    
                    // Move right to (6,5)
                    for (let col = 2; col <= 6; col++) path.push({ row: 6, col });
                    
                    // Move up to (1,6)
                    for (let row = 5; row >= 1; row--) path.push({ row, col: 6 });
                    
                    // Move right to (1,8)
                    for (let col = 7; col <= 8; col++) path.push({ row: 1, col });
                    
                    // Move down to (6,8)
                    for (let row = 2; row <= 6; row++) path.push({ row, col: 8 });
                    
                    // Move right to (6,13)
                    for (let col = 9; col <= 13; col++) path.push({ row: 6, col });
                    
                    // Move down to (8,13)
                    for (let row = 7; row <= 8; row++) path.push({ row, col: 13 });
                    
                    // Move left to (8,8)
                    for (let col = 12; col >= 8; col--) path.push({ row: 8, col });
                    
                    // Move down to (13,8)
                    for (let row = 9; row <= 13; row++) path.push({ row, col: 8 });
                    
                    // Move left to (13,6)
                    for (let col = 7; col >= 6; col--) path.push({ row: 13, col });
                    
                    // Move up to (8,6)
                    for (let row = 12; row >= 8; row--) path.push({ row, col: 6 });
                    
                    // Move left to (8,1)
                    for (let col = 5; col >= 1; col--) path.push({ row: 8, col });
                }
                else if (color === 'blue') {
                    // Blue path: Start at (1,8) and move clockwise
                    path.push({ row: 1, col: 8 }); // Start
                    
                    // Move down to (6,8)
                    for (let row = 2; row <= 6; row++) path.push({ row, col: 8 });
                    
                    // Move right to (6,13)
                    for (let col = 9; col <= 13; col++) path.push({ row: 6, col });
                    
                    // Move down to (8,13)
                    for (let row = 7; row <= 8; row++) path.push({ row, col: 13 });
                    
                    // Move left to (8,8)
                    for (let col = 12; col >= 8; col--) path.push({ row: 8, col });
                    
                    // Move down to (13,8)
                    for (let row = 9; row <= 13; row++) path.push({ row, col: 8 });
                    
                    // Move left to (13,6)
                    for (let col = 7; col >= 6; col--) path.push({ row: 13, col });
                    
                    // Move up to (8,6)
                    for (let row = 12; row >= 8; row--) path.push({ row, col: 6 });
                    
                    // Move left to (8,1)
                    for (let col = 5; col >= 1; col--) path.push({ row: 8, col });
                    
                    // Move up to (6,1)
                    for (let row = 7; row >= 6; row--) path.push({ row, col: 1 });
                    
                    // Move right to (6,6)
                    for (let col = 2; col <= 6; col++) path.push({ row: 6, col });
                    
                    // Move up to (1,6)
                    for (let row = 5; row >= 1; row--) path.push({ row, col: 6 });
                }
                else if (color === 'yellow') {
                    // Yellow path: Start at (8,13) and move clockwise
                    path.push({ row: 8, col: 13 }); // Start
                    
                    // Move left to (8,8)
                    for (let col = 12; col >= 8; col--) path.push({ row: 8, col });
                    
                    // Move down to (13,8)
                    for (let row = 9; row <= 13; row++) path.push({ row, col: 8 });
                    
                    // Move left to (13,6)
                    for (let col = 7; col >= 6; col--) path.push({ row: 13, col });
                    
                    // Move up to (8,6)
                    for (let row = 12; row >= 8; row--) path.push({ row, col: 6 });
                    
                    // Move left to (8,1)
                    for (let col = 5; col >= 1; col--) path.push({ row: 8, col });
                    
                    // Move up to (6,1)
                    for (let row = 7; row >= 6; row--) path.push({ row, col: 1 });
                    
                    // Move right to (6,6)
                    for (let col = 2; col <= 6; col++) path.push({ row: 6, col });
                    
                    // Move up to (1,6)
                    for (let row = 5; row >= 1; row--) path.push({ row, col: 6 });
                    
                    // Move right to (1,8)
                    for (let col = 7; col <= 8; col++) path.push({ row: 1, col });
                    
                    // Move down to (6,8)
                    for (let row = 2; row <= 6; row++) path.push({ row, col: 8 });
                    
                    // Move right to (6,13)
                    for (let col = 9; col <= 13; col++) path.push({ row: 6, col });
                }
                else if (color === 'green') {
                    // Green path: Start at (13,6) and move clockwise
                    path.push({ row: 13, col: 6 }); // Start
                    
                    // Move up to (8,6)
                    for (let row = 12; row >= 8; row--) path.push({ row, col: 6 });
                    
                    // Move left to (8,1)
                    for (let col = 5; col >= 1; col--) path.push({ row: 8, col });
                    
                    // Move up to (6,1)
                    for (let row = 7; row >= 6; row--) path.push({ row, col: 1 });
                    
                    // Move right to (6,6)
                    for (let col = 2; col <= 6; col++) path.push({ row: 6, col });
                    
                    // Move up to (1,6)
                    for (let row = 5; row >= 1; row--) path.push({ row, col: 6 });
                    
                    // Move right to (1,8)
                    for (let col = 7; col <= 8; col++) path.push({ row: 1, col });
                    
                    // Move down to (6,8)
                    for (let row = 2; row <= 6; row++) path.push({ row, col: 8 });
                    
                    // Move right to (6,13)
                    for (let col = 9; col <= 13; col++) path.push({ row: 6, col });
                    
                    // Move down to (8,13)
                    for (let row = 7; row <= 8; row++) path.push({ row, col: 13 });
                    
                    // Move left to (8,8)
                    for (let col = 12; col >= 8; col--) path.push({ row: 8, col });
                    
                    // Move down to (13,8)
                    for (let row = 9; row <= 13; row++) path.push({ row, col: 8 });
                }

                return path;
            }

            function generateFinalPath(color) {
                // Generate the final home path positions for each color (toward the center)
                const path = [];

                if (color === 'red') {
                    // Red final path: from (7,1) to (7,5) then to center
                    path.push({ row: 7, col: 1 }); // Entry point
                    for (let col = 2; col <= 5; col++) {
                        path.push({ row: 7, col });
                    }
                    path.push({ row: 7, col: 6 }); // Center entry
                }
                else if (color === 'blue') {
                    // Blue final path: from (1,7) to (5,7) then to center
                    path.push({ row: 1, col: 7 }); // Entry point
                    for (let row = 2; row <= 5; row++) {
                        path.push({ row, col: 7 });
                    }
                    path.push({ row: 6, col: 7 }); // Center entry
                }
                else if (color === 'yellow') {
                    // Yellow final path: from (7,13) to (7,9) then to center
                    path.push({ row: 7, col: 13 }); // Entry point
                    for (let col = 12; col >= 9; col--) {
                        path.push({ row: 7, col });
                    }
                    path.push({ row: 7, col: 8 }); // Center entry
                }
                else if (color === 'green') {
                    // Green final path: from (13,7) to (9,7) then to center
                    path.push({ row: 13, col: 7 }); // Entry point
                    for (let row = 12; row >= 9; row--) {
                        path.push({ row, col: 7 });
                    }
                    path.push({ row: 8, col: 7 }); // Center entry
                }

                return path;
            }

            function renderBoard() {
                const boardElement = document.getElementById('ludoBoard');
                boardElement.innerHTML = '';

                for (let row = 0; row < 15; row++) {
                    for (let col = 0; col < 15; col++) {
                        const cell = document.createElement('div');
                        cell.className = `cell ${board[row][col]}`;
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        
                        // Add special markers for start positions using CSS class instead of inline styles
                        if (board[row][col].includes('start-')) {
                            const star = document.createElement('div');
                            star.className = 'start-marker';
                            cell.appendChild(star);
                        }
                        
                        boardElement.appendChild(cell);
                    }
                }
            }

            function placeTokens() {
                // Use token cache for better performance
                const existingTokens = new Map();
                document.querySelectorAll('.token').forEach(token => {
                    const key = `${token.dataset.color}-${token.dataset.tokenId}`;
                    existingTokens.set(key, token);
                });
                
                // Clear only tokens that need to be moved
                for (const color of players) {
                    for (const token of tokens[color]) {
                        if (token.completed) {
                            const key = `${color}-${token.id}`;
                            const existingToken = existingTokens.get(key);
                            if (existingToken) existingToken.remove();
                            continue;
                        }
                        
                        let targetCell;
                        if (token.position === 'home') {
                            targetCell = document.querySelector(`[data-row="${token.homePosition.row}"][data-col="${token.homePosition.col}"]`);
                        } else if (token.position === 'final') {
                            const pathPos = finalPaths[color][token.pathIndex];
                            targetCell = document.querySelector(`[data-row="${pathPos.row}"][data-col="${pathPos.col}"]`);
                        } else {
                            const pathPos = paths[color][token.pathIndex];
                            targetCell = document.querySelector(`[data-row="${pathPos.row}"][data-col="${pathPos.col}"]`);
                        }
                        
                        if (targetCell) {
                            const key = `${color}-${token.id}`;
                            let tokenElement = existingTokens.get(key);
                            
                            if (!tokenElement) {
                                tokenElement = document.createElement('div');
                                tokenElement.className = `token token-${color} token-${token.id}`;
                                tokenElement.dataset.color = color;
                                tokenElement.dataset.tokenId = token.id;
                                tokenElement.addEventListener('click', () => onTokenClick(color, token.id));
                            }
                            
                            // Remove from previous position if needed
                            if (tokenElement.parentElement && tokenElement.parentElement !== targetCell) {
                                tokenElement.remove();
                            }
                            
                            // Handle token stacking with visual offset
                            const existingTokensInCell = targetCell.querySelectorAll('.token');
                            if (existingTokensInCell.length > 0) {
                                const offset = existingTokensInCell.length * 4;
                                tokenElement.style.transform = `translate(${offset}px, ${offset}px)`;
                                tokenElement.style.zIndex = existingTokensInCell.length + 1;
                            } else {
                                tokenElement.style.transform = '';
                                tokenElement.style.zIndex = '';
                            }
                            
                            // Only append if not already in correct cell
                            if (!targetCell.contains(tokenElement)) {
                                targetCell.appendChild(tokenElement);
                            }
                        }
                    }
                }
            }

            function onTokenClick(color, tokenId) {
                if (!gameActive || color !== getCurrentPlayer()) return;
                
                const token = tokens[color].find(t => t.id === tokenId);
                if (!token) return;
                
                // Remove any existing highlights
                document.querySelectorAll('.highlight-move').forEach(el => {
                    el.classList.remove('highlight-move');
                });
                
                // Check if the token can be moved
                if (canMoveToken(color, tokenId)) {
                    playSound('tokenMoveSound');
                    moveToken(color, tokenId);
                }
            }

            function canMoveToken(color, tokenId) {
                const token = tokens[color].find(t => t.id === tokenId);
                
                // If token is already completed, cannot move
                if (token.completed) return false;
                
                // If token is in home, can only move if dice is 6
                if (token.position === 'home' && diceValue === 6) {
                    return true;
                }
                
                // If token is on the main path, check if move is valid
                if (token.position === 'path') {
                    const newPathIndex = token.pathIndex + diceValue;
                    
                    // Check if move would enter final path
                    if (newPathIndex >= paths[color].length) {
                        const finalPathIndex = newPathIndex - paths[color].length;
                        
                        // Check if final path index is valid
                        if (finalPathIndex < finalPaths[color].length) {
                            return true;
                        } else {
                            // Move would overshoot the final path - need exact dice value
                            return false;
                        }
                    }
                    
                    // Check if the target position is occupied by another token of the same color
                    const targetPos = paths[color][newPathIndex];
                    const tokensAtTarget = getTokensAtPosition(targetPos.row, targetPos.col);
                    const sameColorTokens = tokensAtTarget.filter(t => t.color === color);
                    
                    // Cannot land on a cell with multiple tokens of the same color
                    if (sameColorTokens.length > 0) {
                        return false;
                    }
                    
                    return true;
                }
                
                // If token is on the final path
                if (token.position === 'final') {
                    const newPathIndex = token.pathIndex + diceValue;
                    
                    // Check if move would complete the token - FIXED: Need exact dice value
                    if (newPathIndex > finalPaths[color].length) {
                        return false; // Overshooting not allowed
                    }
                    if (newPathIndex === finalPaths[color].length) {
                        return true; // Exact value to complete
                    }
                    
                    // Check if target position in final path is occupied
                    const targetPos = finalPaths[color][newPathIndex];
                    const tokensAtTarget = getTokensAtPosition(targetPos.row, targetPos.col);
                    const sameColorTokens = tokensAtTarget.filter(t => t.color === color);
                    
                    if (sameColorTokens.length > 0) {
                        return false;
                    }
                    
                    return true;
                }
                
                return false;
            }

            function moveToken(color, tokenId) {
                const token = tokens[color].find(t => t.id === tokenId);
                
                if (token.position === 'home') {
                    // Move token from home to start
                    token.position = 'path';
                    token.pathIndex = 0;
                    
                    // Place token at starting position
                    const startPos = startPositions[color];
                    captureTokensAt(startPos.row, startPos.col, color);
                    
                } else if (token.position === 'path') {
                    const newPathIndex = token.pathIndex + diceValue;
                    
                    // Check if token would enter final path
                    if (newPathIndex >= paths[color].length) {
                        const finalPathIndex = newPathIndex - paths[color].length;
                        
                        // Check if final path index is valid
                        if (finalPathIndex < finalPaths[color].length) {
                            token.position = 'final';
                            token.pathIndex = finalPathIndex;
                        } else {
                            // Token cannot move - overshoots final path
                            return;
                        }
                    } else {
                        // Move token along the main path
                        token.pathIndex = newPathIndex;
                        
                        // Check for captures
                        const newPos = paths[color][token.pathIndex];
                        captureTokensAt(newPos.row, newPos.col, color);
                    }
                } else if (token.position === 'final') {
                    const newPathIndex = token.pathIndex + diceValue;
                    
                    // Check if token completes the journey - FIXED: Exact dice value required
                    if (newPathIndex === finalPaths[color].length) {
                        token.completed = true;
                        checkWinCondition();
                    } else if (newPathIndex < finalPaths[color].length) {
                        // Move token along the final path
                        token.pathIndex = newPathIndex;
                    } else {
                        // Cannot move - overshoots completion
                        return;
                    }
                }
                
                // Update the board with optimized rendering
                placeTokens();
                
                // Reset consecutive sixes only if not a six
                if (diceValue !== 6) {
                    consecutiveSixes = 0;
                }
                
                // FIXED: After moving a token, player must roll dice again for next move
                // Even if they rolled a 6, they need to roll again for the next move
                updateGameStatus();
                document.getElementById('rollBtn').disabled = false;
                
                // Disable token clicks until player rolls dice again
                document.querySelectorAll('.token').forEach(token => {
                    token.style.pointerEvents = 'none';
                });
                
                // Only move to next turn if dice value is not 6
                if (diceValue !== 6) {
                    nextTurn();
                }
            }

            function captureTokensAt(row, col, capturingColor) {
                // Get all tokens at the target position
                const tokensAtPos = getTokensAtPosition(row, col);
                
                // Send opponent tokens back to their home (only if not in safe zone)
                for (const tokenInfo of tokensAtPos) {
                    if (tokenInfo.color !== capturingColor && !isSafeCell(row, col, tokenInfo.color)) {
                        const token = tokens[tokenInfo.color].find(t => t.id === tokenInfo.id);
                        if (token && !token.completed) {
                            token.position = 'home';
                            token.pathIndex = -1;
                        }
                    }
                }
            }

            function getTokensAtPosition(row, col) {
                const tokensAtPos = [];
                
                for (const color of players) {
                    for (const token of tokens[color]) {
                        if (token.completed) continue;
                        
                        if (token.position === 'home') {
                            if (token.homePosition.row === row && token.homePosition.col === col) {
                                tokensAtPos.push({color, id: token.id});
                            }
                        } else if (token.position === 'final') {
                            const pathPos = finalPaths[color][token.pathIndex];
                            if (pathPos.row === row && pathPos.col === col) {
                                tokensAtPos.push({color, id: token.id});
                            }
                        } else {
                            const pathPos = paths[color][token.pathIndex];
                            if (pathPos.row === row && pathPos.col === col) {
                                tokensAtPos.push({color, id: token.id});
                            }
                        }
                    }
                }
                
                return tokensAtPos;
            }

            function isSafeCell(row, col, tokenColor = null) {
                // Safe cells include colored safe zones and home areas
                // FIXED: Start positions are NOT safe for opponents
                const cellType = board[row][col];
                
                // All safe zones are safe
                if (cellType.includes('safe-')) return true;
                
                // Start positions are only safe for the owner
                if (cellType.includes('start-')) {
                    if (tokenColor && cellType === `start-${tokenColor}`) {
                        return true;
                    }
                    return false;
                }
                
                // Center is safe
                if (cellType === 'center') return true;
                
                // Home cells are only safe for tokens of the same color
                if (cellType.includes('home-')) {
                    if (tokenColor && cellType === `home-${tokenColor}`) {
                        return true;
                    }
                    return false;
                }
                
                return false;
            }

            function rollDice() {
                if (!gameActive) return;
                
                const diceElement = document.getElementById('dice');
                const rollBtn = document.getElementById('rollBtn');
                
                // Disable roll button during animation
                rollBtn.disabled = true;
                
                // Disable all token clicks during dice roll
                document.querySelectorAll('.token').forEach(token => {
                    token.style.pointerEvents = 'none';
                });
                
                diceElement.classList.add('rolling');
                playSound('diceRollSound');
                
                // Simulate dice rolling with optimized animation
                let rolls = 0;
                const maxRolls = 12; // Reduced for better UX
                const rollInterval = setInterval(() => {
                    diceValue = Math.floor(Math.random() * 6) + 1;
                    diceElement.textContent = diceValue;
                    rolls++;
                    
                    if (rolls >= maxRolls) {
                        clearInterval(rollInterval);
                        diceElement.classList.remove('rolling');
                        handleDiceResult();
                    }
                }, 80);
            }

            function handleDiceResult() {
                // Check for three consecutive sixes
                if (diceValue === 6) {
                    consecutiveSixes++;
                    if (consecutiveSixes === 3) {
                        // Penalty: send all tokens of current player back to home
                        const currentPlayer = getCurrentPlayer();
                        tokens[currentPlayer].forEach(token => {
                            if (!token.completed) {
                                token.position = 'home';
                                token.pathIndex = -1;
                            }
                        });
                        placeTokens();
                        consecutiveSixes = 0;
                        nextTurn();
                        return;
                    }
                } else {
                    consecutiveSixes = 0;
                }
                
                // Check if any moves are possible
                const currentPlayer = getCurrentPlayer();
                const movableTokens = tokens[currentPlayer].filter(token => 
                    canMoveToken(currentPlayer, token.id)
                );
                
                if (movableTokens.length === 0) {
                    // No possible moves
                    if (diceValue === 6) {
                        // Player gets another turn if they rolled a 6 but have no moves
                        updateGameStatus();
                        document.getElementById('rollBtn').disabled = false;
                        // Don't enable tokens since no moves are possible
                    } else {
                        nextTurn();
                    }
                } else {
                    // Enable token selection for current player
                    updateGameStatus();
                    
                    // Enable token clicks for current player only
                    enableCurrentPlayerTokens();
                    
                    // Auto-move if only one valid move
                    if (movableTokens.length === 1) {
                        const tokenToMove = movableTokens[0];
                        const tokenElement = document.querySelector(`.token-${currentPlayer}.token-${tokenToMove.id}`);
                        if (tokenElement) {
                            tokenElement.classList.add('highlight-move');
                            setTimeout(() => {
                                tokenElement.classList.remove('highlight-move');
                                moveToken(currentPlayer, tokenToMove.id);
                            }, 600);
                        } else {
                            setTimeout(() => {
                                moveToken(currentPlayer, tokenToMove.id);
                            }, 400);
                        }
                    }
                    
                    // If it's an AI player's turn, make AI move
                    if (gameMode === 'ai' && currentPlayer !== 'red') {
                        makeAIMove();
                    }
                }
            }

            function makeAIMove() {
                const currentPlayer = getCurrentPlayer();
                const movableTokens = tokens[currentPlayer].filter(token => 
                    canMoveToken(currentPlayer, token.id)
                );
                
                if (movableTokens.length === 0) {
                    nextTurn();
                    return;
                }
                
                // Show AI thinking indicator
                aiThinking.classList.add('show');
                
                // AI decision making with delay to simulate thinking
                aiThinkingTimeout = setTimeout(() => {
                    aiThinking.classList.remove('show');
                    
                    // Enhanced AI strategy:
                    // 1. Prefer moves that capture opponents
                    // 2. Prefer moves that complete tokens
                    // 3. Prefer moving tokens out of home
                    // 4. Prefer moving tokens that are closer to completion
                    // 5. Avoid moving tokens into dangerous positions
                    
                    let bestToken = null;
                    let bestScore = -1;
                    
                    for (const token of movableTokens) {
                        let score = 0;
                        
                        // If token is in home and dice is 6, prioritize moving it out
                        if (token.position === 'home' && diceValue === 6) {
                            score += 100;
                        }
                        
                        // Calculate potential capture score
                        if (token.position === 'path') {
                            const newPathIndex = token.pathIndex + diceValue;
                            if (newPathIndex < paths[currentPlayer].length) {
                                const newPos = paths[currentPlayer][newPathIndex];
                                const tokensAtTarget = getTokensAtPosition(newPos.row, newPos.col);
                                const opponentTokens = tokensAtTarget.filter(t => t.color !== currentPlayer);
                                
                                if (opponentTokens.length > 0 && !isSafeCell(newPos.row, newPos.col, currentPlayer)) {
                                    score += 80; // High priority for captures
                                }
                            }
                        }
                        
                        // Prefer moves that complete tokens
                        if (token.position === 'final') {
                            const newPathIndex = token.pathIndex + diceValue;
                            if (newPathIndex === finalPaths[currentPlayer].length) {
                                score += 150; // Highest priority for completing tokens
                            }
                        }
                        
                        // Prefer tokens that are further along in the path
                        if (token.position === 'path') {
                            score += token.pathIndex;
                        } else if (token.position === 'final') {
                            score += paths[currentPlayer].length + token.pathIndex;
                        }
                        
                        // Avoid moving tokens into dangerous positions (where they can be captured)
                        if (token.position === 'path') {
                            const newPathIndex = token.pathIndex + diceValue;
                            if (newPathIndex < paths[currentPlayer].length) {
                                const newPos = paths[currentPlayer][newPathIndex];
                                if (!isSafeCell(newPos.row, newPos.col, currentPlayer)) {
                                    // Check if there are opponent tokens nearby that could capture this token
                                    const nearbyOpponents = getNearbyOpponents(newPos.row, newPos.col, currentPlayer);
                                    if (nearbyOpponents > 0) {
                                        score -= 30; // Penalize dangerous moves
                                    }
                                }
                            }
                        }
                        
                        // If this is a better move than the current best, update
                        if (score > bestScore) {
                            bestScore = score;
                            bestToken = token;
                        }
                    }
                    
                    // Move the selected token
                    if (bestToken) {
                        moveToken(currentPlayer, bestToken.id);
                    } else {
                        // Fallback: move the first movable token
                        moveToken(currentPlayer, movableTokens[0].id);
                    }
                }, 1000 + Math.random() * 1000); // Random delay between 1-2 seconds
            }

            function getNearbyOpponents(row, col, currentPlayer) {
                // Check for opponent tokens that could capture this token in their next move
                let nearbyOpponents = 0;
                
                for (const color of players) {
                    if (color === currentPlayer) continue;
                    
                    for (const token of tokens[color]) {
                        if (token.position === 'home') continue;
                        
                        // Check if opponent token is on the main path and could reach this position
                        if (token.position === 'path') {
                            const distance = calculateDistance(token, row, col, color);
                            if (distance <= 6 && distance > 0) {
                                nearbyOpponents++;
                            }
                        }
                    }
                }
                
                return nearbyOpponents;
            }

            function calculateDistance(token, targetRow, targetCol, color) {
                // Calculate the distance between a token and a target position
                if (token.position === 'home') return Infinity;
                
                if (token.position === 'path') {
                    const currentPos = paths[color][token.pathIndex];
                    let distance = 0;
                    let currentIndex = token.pathIndex;
                    
                    // Calculate distance along the path
                    while (currentIndex < paths[color].length) {
                        const pos = paths[color][currentIndex];
                        if (pos.row === targetRow && pos.col === targetCol) {
                            return distance;
                        }
                        distance++;
                        currentIndex++;
                    }
                    
                    // If not found in the main path, check the final path
                    currentIndex = 0;
                    while (currentIndex < finalPaths[color].length) {
                        const pos = finalPaths[color][currentIndex];
                        if (pos.row === targetRow && pos.col === targetCol) {
                            return distance + currentIndex;
                        }
                        currentIndex++;
                    }
                } else if (token.position === 'final') {
                    const currentPos = finalPaths[color][token.pathIndex];
                    let distance = 0;
                    let currentIndex = token.pathIndex;
                    
                    // Calculate distance along the final path
                    while (currentIndex < finalPaths[color].length) {
                        const pos = finalPaths[color][currentIndex];
                        if (pos.row === targetRow && pos.col === targetCol) {
                            return distance;
                        }
                        distance++;
                        currentIndex++;
                    }
                }
                
                return Infinity;
            }

            function enableCurrentPlayerTokens() {
                const currentPlayer = getCurrentPlayer();
                document.querySelectorAll('.token').forEach(token => {
                    if (token.dataset.color === currentPlayer) {
                        token.style.pointerEvents = 'auto';
                    } else {
                        token.style.pointerEvents = 'none';
                    }
                });
            }

            function nextTurn() {
                currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
                diceValue = 1;
                document.getElementById('dice').textContent = diceValue;
                document.getElementById('rollBtn').disabled = false;
                updateGameStatus();
                
                // Enable token clicks for new current player only
                enableCurrentPlayerTokens();
                
                // If it's an AI player's turn, automatically roll the dice
                if (gameMode === 'ai' && getCurrentPlayer() !== 'red') {
                    setTimeout(() => {
                        rollDice();
                    }, 500);
                }
            }

            function getCurrentPlayer() {
                return players[currentPlayerIndex];
            }

            function updateGameStatus() {
                const gameStatus = document.getElementById('gameStatus');
                const currentPlayer = getCurrentPlayer();
                const playerName = currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1);
                
                // Update active player highlight
                document.querySelectorAll('.player').forEach(player => player.classList.remove('active'));
                const playerElement = document.getElementById(`player${playerName}`);
                if (playerElement) {
                    playerElement.classList.add('active');
                }
                
                // Update game status text
                if (diceValue === 6) {
                    gameStatus.textContent = `${playerName} Player rolled a 6! Roll again or move a token`;
                } else {
                    gameStatus.textContent = `${playerName} Player's Turn - Roll the dice`;
                }
                
                // Update token completion status
                updatePlayerTokensDisplay();
            }

            function updatePlayerTokensDisplay() {
                for (const color of players) {
                    const tokensContainer = document.getElementById(`${color}Tokens`);
                    if (!tokensContainer) continue;
                    
                    const playerTokens = tokens[color];
                    
                    tokensContainer.innerHTML = '';
                    for (const token of playerTokens) {
                        const tokenElement = document.createElement('div');
                        tokenElement.className = `player-token token-${color}`;
                        if (token.completed) {
                            tokenElement.classList.add('completed');
                        }
                        tokensContainer.appendChild(tokenElement);
                    }
                }
            }

            function checkWinCondition() {
                const currentPlayer = getCurrentPlayer();
                const allCompleted = tokens[currentPlayer].every(token => token.completed);
                
                if (allCompleted) {
                    gameActive = false;
                    playSound('winSound');
                    showWinningMessage(currentPlayer);
                }
            }

            function showWinningMessage(winner) {
                const winnerText = document.getElementById('winnerText');
                const rollBtn = document.getElementById('rollBtn');
                
                if (winnerText && winningMessage) {
                    winnerText.textContent = `${winner.charAt(0).toUpperCase() + winner.slice(1)} Player Wins!`;
                    winningMessage.classList.add('show');
                }
                
                // Disable dice button after winning
                if (rollBtn) {
                    rollBtn.disabled = true;
                }
                
                // Disable all token clicks
                document.querySelectorAll('.token').forEach(token => {
                    token.style.pointerEvents = 'none';
                });
            }

            function playSound(soundId) {
                const sound = document.getElementById(soundId);
                if (sound) {
                    sound.currentTime = 0;
                    sound.play().catch(e => console.log("Sound play prevented:", e));
                }
            }

            function resetGame() {
                const rollBtn = document.getElementById('rollBtn');
                
                if (winningMessage) {
                    winningMessage.classList.remove('show');
                }
                
                // Clear AI thinking timeout if exists
                if (aiThinkingTimeout) {
                    clearTimeout(aiThinkingTimeout);
                }
                
                // Show setup screen again
                gameSetup.style.display = 'flex';
                gameControls.style.display = 'none';
                gameBoardContainer.style.display = 'none';
                playerInfo.style.display = 'none';
                gameRules.style.display = 'none';
                
                gameActive = false;
            }

            // ===== BUTTON EVENT LISTENERS =====
            // Game control buttons
            document.getElementById('startBtn').addEventListener('click', startGame);
            document.getElementById('rollBtn').addEventListener('click', rollDice);
            document.getElementById('newGameBtn').addEventListener('click', resetGame);
            
            // ===== NAVIGATION BUTTONS =====
            // Back button - SIMPLE AND DIRECT
            document.getElementById('btnBack').addEventListener('click', function() {
                window.location.href = 'games.html';
            });
            
            // Exit button - SIMPLE AND DIRECT
            document.getElementById('btnExit').addEventListener('click', function() {
                if (confirm('Are you sure you want to exit GameNest?')) {
                    window.location.href = 'index.html';
                }
            });
            
            // ===== MUSIC BUTTON =====
            document.getElementById('musicToggle').addEventListener('click', function() {
                const backgroundMusic = document.getElementById('backgroundMusic');
                if (!backgroundMusic) return;
                
                if (backgroundMusic.paused) {
                    backgroundMusic.play().catch(e => console.log("Music play prevented:", e));
                    this.classList.add('playing');
                    this.innerHTML = '<i class="fas fa-volume-up"></i>';
                } else {
                    backgroundMusic.pause();
                    this.classList.remove('playing');
                    this.innerHTML = '<i class="fas fa-volume-mute"></i>';
                }
            });
            
            // ===== BOT ASSISTANT =====
            const botToggle = document.getElementById('botToggle');
            const botAssistant = document.getElementById('botAssistant');
            const botClose = document.getElementById('botClose');
            
            if (botToggle && botAssistant) {
                botToggle.addEventListener('click', function() {
                    botAssistant.classList.toggle('active');
                });
                
                botClose.addEventListener('click', function() {
                    botAssistant.classList.remove('active');
                });
                
                document.addEventListener('click', function(event) {
                    if (botAssistant.classList.contains('active') && 
                        !botAssistant.contains(event.target) && 
                        !botToggle.contains(event.target)) {
                        botAssistant.classList.remove('active');
                    }
                });
            }
            
            // Bot questions with typing effect
            document.querySelectorAll('.bot-question').forEach(question => {
                question.addEventListener('click', function() {
                    const questionType = this.getAttribute('data-question');
                    handleBotQuestion(questionType);
                });
            });
            
            function handleBotQuestion(questionType) {
                const botMessages = document.querySelector('.bot-messages');
                
                // Clear previous responses (keep the initial message)
                const initialMessage = botMessages.querySelector('.bot-message:first-child');
                botMessages.innerHTML = '';
                if (initialMessage) {
                    botMessages.appendChild(initialMessage);
                }
                
                // Create new response
                const response = document.createElement('div');
                response.classList.add('bot-message');
                
                let responseText = '';
                
                switch(questionType) {
                    case 'ludo-rules':
                        responseText = 'Ludo Game Rules:<br>' +
                                      'â€¢ Roll a 6 to move a token out of your home area<br>' +
                                      'â€¢ Move tokens clockwise around the board<br>' +
                                      'â€¢ Land on an opponent\'s token to send it home<br>' +
                                      'â€¢ First to get all tokens to the center wins<br>' +
                                      'â€¢ Three consecutive 6s sends all your tokens home';
                        break;
                    case 'ludo-tips':
                        responseText = 'Winning Tips:<br>' +
                                      'â€¢ Try to keep tokens together for protection<br>' +
                                      'â€¢ Use 6s strategically to move multiple tokens<br>' +
                                      'â€¢ Block opponents by placing tokens in their path<br>' +
                                      'â€¢ Prioritize tokens closer to the finish line<br>' +
                                      'â€¢ Watch for opportunities to capture opponents';
                        break;
                    case 'ludo-strategy':
                        responseText = 'Advanced Strategies:<br>' +
                                      'â€¢ Balance between offense and defense<br>' +
                                      'â€¢ Use safe zones strategically<br>' +
                                      'â€¢ Keep one token near home as a backup<br>' +
                                      'â€¢ Time your captures for maximum impact<br>' +
                                      'â€¢ Plan several moves ahead when possible';
                        break;
                    default:
                        responseText = 'I\'m not sure how to help with that. Try asking about Ludo rules or strategies!';
                }
                
                // Add typing cursor
                response.innerHTML = `<p><span class="typing-text"></span><span class="typing-cursor"></span></p>`;
                botMessages.appendChild(response);
                
                // Type out the response
                typeText(response.querySelector('.typing-text'), responseText);
                
                // Scroll to bottom of messages
                botMessages.scrollTop = botMessages.scrollHeight;
            }
            
            function typeText(element, text, speed = 30) {
                let i = 0;
                element.innerHTML = '';
                
                function type() {
                    if (i < text.length) {
                        if (text.substring(i, i + 4) === '<br>') {
                            element.innerHTML += '<br>';
                            i += 4;
                        } else if (text.substring(i, i + 2) === 'â€¢ ') {
                            element.innerHTML += 'â€¢ ';
                            i += 2;
                        } else {
                            element.innerHTML += text.charAt(i);
                            i++;
                        }
                        setTimeout(type, speed);
                    } else {
                        const cursor = element.parentNode.querySelector('.typing-cursor');
                        if (cursor) {
                            cursor.style.display = 'none';
                        }
                    }
                }
                type();
            }
            
            // ===== INITIALIZATION =====
            createParticles();
            initializeGameElements();
            initializeMusic(); // Initialize auto-play music
        });
    </script>
</body>
</html>