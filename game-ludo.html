<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ludo Game — Milah Special</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --red: #E53935;
            --green: #43A047;
            --blue: #1E88E5;
            --yellow: #FDD835;
            --board-bg: #f5f5f5;
            --wood-color: #8B4513;
            --wood-light: #A0522D;
            --wood-dark: #654321;
            --primary-color: #6c5ce7;
            --secondary-color: #a29bfe;
            --accent-color: #fd79a8;
            --dark-color: #2d3436;
            --light-color: #dfe6e9;
            --card-bg: rgba(255, 255, 255, 0.1);
            --card-glow: rgba(255, 255, 255, 0.15);
            --card-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            --border-radius: 20px;
            --transition: all 0.3s ease;
            --game-bg: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
        }

        body {
            background: var(--game-bg);
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            color: white;
            position: relative;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 107, 107, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(77, 201, 208, 0.05) 0%, transparent 50%);
            z-index: -1;
        }

        .container {
            max-width: 1200px;
        }

        h1 {
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            font-weight: 700;
            margin-bottom: 30px;
            background: linear-gradient(to right, #a29bfe, #fd79a8, #00b894);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            letter-spacing: 1px;
            position: relative;
            padding-bottom: 10px;
        }

        h1::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 3px;
            background: linear-gradient(to right, #a29bfe, #fd79a8, #00b894);
            border-radius: 3px;
        }

        .ludo-board-container {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            perspective: 1000px;
        }

        .ludo-board {
            display: grid;
            grid-template-columns: repeat(15, 1fr);
            grid-template-rows: repeat(15, 1fr);
            width: 600px;
            height: 600px;
            border: 12px solid var(--wood-color);
            box-shadow: 
                0 10px 30px rgba(0, 0, 0, 0.5),
                inset 0 0 20px rgba(139, 69, 19, 0.3);
            background-color: white;
            position: relative;
            border-radius: 15px;
            transform: rotateX(5deg);
            transition: transform 0.5s ease;
        }

        .ludo-board:hover {
            transform: rotateX(5deg) translateY(-5px);
        }

        .cell {
            border: 1px solid rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
            font-size: 12px;
        }

        .home {
            grid-area: var(--start-row) / var(--start-col) / span 6 / span 6;
            background: radial-gradient(circle at 30% 30%, var(--color) 0%, var(--color-dark) 100%);
            border: 5px solid var(--wood-color);
            z-index: 10;
            border-radius: 12px;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
        }

        .home::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.2) 0%, rgba(0,0,0,0.1) 100%);
            border-radius: 8px;
        }

        .home.red { 
            --color: var(--red); 
            --color-dark: #C62828;
            --start-row: 1; 
            --start-col: 1; 
        }
        .home.green { 
            --color: var(--green); 
            --color-dark: #2E7D32;
            --start-row: 1; 
            --start-col: 10; 
        }
        .home.blue { 
            --color: var(--blue); 
            --color-dark: #1565C0;
            --start-row: 10; 
            --start-col: 1; 
        }
        .home.yellow { 
            --color: var(--yellow); 
            --color-dark: #F9A825;
            --start-row: 10; 
            --start-col: 10; 
        }

        .start-area {
            width: 80%;
            height: 80%;
            background-color: rgba(255, 255, 255, 0.9);
            border: 3px solid var(--wood-color);
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 10px;
            padding: 15px;
            border-radius: 10px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2);
        }

        .token-hole {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, var(--color) 0%, var(--color-dark) 100%);
            box-shadow: 
                inset 0 0 10px rgba(0,0,0,0.5),
                0 3px 5px rgba(0,0,0,0.2);
            border: 2px solid rgba(255,255,255,0.5);
            transition: all 0.3s ease;
        }

        .token-hole:hover {
            transform: scale(1.05);
        }

        .start-square {
            border: 4px solid var(--wood-color);
            border-radius: 8px;
            box-shadow: 0 3px 5px rgba(0,0,0,0.2);
            position: relative;
            z-index: 5;
        }
        .start-square::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.3) 0%, rgba(0,0,0,0.1) 100%);
            border-radius: 4px;
        }
        .start-square.red { background: linear-gradient(135deg, var(--red) 0%, #C62828 100%); }
        .start-square.green { background: linear-gradient(135deg, var(--green) 0%, #2E7D32 100%); }
        .start-square.blue { background: linear-gradient(135deg, var(--blue) 0%, #1565C0 100%); }
        .start-square.yellow { background: linear-gradient(135deg, var(--yellow) 0%, #F9A825 100%); }

        .home-path { 
            background: linear-gradient(135deg, var(--color) 0%, var(--color-dark) 100%);
            position: relative;
        }
        .home-path::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.2) 0%, rgba(0,0,0,0.1) 100%);
        }
        .home-path.red { --color: var(--red); --color-dark: #C62828; }
        .home-path.green { --color: var(--green); --color-dark: #2E7D32; }
        .home-path.yellow { --color: var(--yellow); --color-dark: #F9A825; }
        .home-path.blue { --color: var(--blue); --color-dark: #1565C0; }

        .center-home {
            grid-area: 7 / 7 / span 3 / span 3;
            border: none;
            position: relative;
            z-index: 10;
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
        }
        .center-triangle {
            position: absolute;
            width: 100%;
            height: 100%;
            transition: all 0.3s ease;
        }
        .center-triangle.red { 
            background: linear-gradient(135deg, var(--red) 0%, #C62828 100%); 
            clip-path: polygon(50% 50%, 0% 0%, 0% 100%, 50% 50%); 
        }
        .center-triangle.green { 
            background: linear-gradient(135deg, var(--green) 0%, #2E7D32 100%); 
            clip-path: polygon(50% 50%, 0% 0%, 100% 0%, 50% 50%); 
        }
        .center-triangle.blue { 
            background: linear-gradient(135deg, var(--blue) 0%, #1565C0 100%); 
            clip-path: polygon(50% 50%, 0% 100%, 100% 100%, 50% 50%); 
        }
        .center-triangle.yellow { 
            background: linear-gradient(135deg, var(--yellow) 0%, #F9A825 100%); 
            clip-path: polygon(50% 50%, 100% 0%, 100% 100%, 50% 50%); 
        }

        .safe-square {
            position: relative;
            background: white;
            border-radius: 50%;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
        }
        .safe-square::after {
            content: '';
            position: absolute;
            top: 20%;
            left: 20%;
            right: 20%;
            bottom: 20%;
            border-radius: 50%;
            background: var(--color);
            box-shadow: inset 0 0 5px rgba(0,0,0,0.3);
        }

        /* --- TOKEN VISUALS --- */
        .token {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: 700;
            box-shadow: 
                0 4px 8px rgba(0,0,0,0.4),
                inset 0 -3px 5px rgba(0,0,0,0.2),
                inset 0 3px 5px rgba(255,255,255,0.3);
            position: absolute;
            transition: all 400ms cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 50;
            cursor: pointer;
            border: 2px solid rgba(255,255,255,0.8);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .token.red { 
            background: radial-gradient(circle at 30% 30%, var(--red) 0%, #C62828 100%); 
        }
        .token.green { 
            background: radial-gradient(circle at 30% 30%, var(--green) 0%, #2E7D32 100%); 
        }
        .token.blue { 
            background: radial-gradient(circle at 30% 30%, var(--blue) 0%, #1565C0 100%); 
        }
        .token.yellow { 
            background: radial-gradient(circle at 30% 30%, var(--yellow) 0%, #F9A825 100%); 
            color: #333;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.5);
        }

        .token.movable {
            transform: scale(1.1);
            box-shadow: 
                0 0 0 3px rgba(255,255,255,0.8), 
                0 0 15px 5px rgba(255,255,255,0.6),
                0 4px 8px rgba(0,0,0,0.4),
                inset 0 -3px 5px rgba(0,0,0,0.2),
                inset 0 3px 5px rgba(255,255,255,0.3);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1.05); }
            50% { transform: scale(1.15); }
            100% { transform: scale(1.05); }
        }

        .token.moving {
            z-index: 60;
            transform: scale(1.2);
        }

        .token.finished {
            opacity: 0.7;
            transform: scale(0.9);
        }

        /* Controls */
        .game-ui {
            margin-left: 30px;
            max-width: 320px;
            background: var(--card-bg);
            backdrop-filter: blur(20px);
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: var(--card-shadow);
            border: 1px solid var(--card-glow);
            position: relative;
            overflow: hidden;
        }
        
        .game-ui::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background: linear-gradient(to right, #00b894, #55efc4);
        }
        
        .board-wrapper {
            display: flex;
            align-items: flex-start;
            justify-content: center;
        }

        .dice {
            width: 80px;
            height: 80px;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            font-weight: bold;
            border: 4px solid var(--wood-color);
            background: rgb(133, 88, 88);
            cursor: pointer;
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .dice::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.8) 0%, rgba(0,0,0,0.1) 100%);
            border-radius: 11px;
        }

        .dice.rolling {
            animation: shake 0.5s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-10deg); }
            75% { transform: rotate(10deg); }
        }

        .dice:hover:not(.rolling) {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        }

        .small { font-size: 14px; }

        .highlight { box-shadow: 0 0 10px 3px rgba(0,0,0,0.12); }

        .status-message {
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%);
            padding: 12px;
            border-radius: 10px;
            margin: 10px 0;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-weight: 500;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }

        .btn {
            margin-right: 5px;
            margin-bottom: 5px;
            border-radius: 8px;
            font-weight: 600;
            box-shadow: 0 3px 5px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            border: none;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 8px rgba(0,0,0,0.3);
        }

        .btn-success {
            background: linear-gradient(135deg, #00b894, #55efc4);
        }

        .player-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 10px 0;
        }

        .player-control {
            flex: 1;
            min-width: 120px;
        }

        .form-check-input:checked {
            background-color: var(--bs-success);
            border-color: var(--bs-success);
        }

        .winner-list {
            margin-top: 15px;
            padding: 15px;
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%);
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .winner-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            padding: 5px;
            border-radius: 5px;
            background: rgba(255,255,255,0.1);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .winner-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .list-group-item {
            border-radius: 8px !important;
            margin-bottom: 5px;
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
            background: rgba(255,255,255,0.1);
            color: white;
        }

        .list-group-item.active {
            transform: scale(1.02);
            box-shadow: 0 3px 8px rgba(0,0,0,0.2);
            background: rgba(255,255,255,0.2);
        }

        /* Fixed Navigation Buttons */
        .fixed-back-btn, .fixed-exit-btn {
            position: fixed;
            top: 30px;
            width: 55px;
            height: 55px;
            border-radius: 50%;
            background: var(--card-bg);
            border: 1px solid var(--card-glow);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.3rem;
            cursor: pointer;
            transition: var(--transition);
            backdrop-filter: blur(15px);
            box-shadow: var(--card-shadow);
            z-index: 1000;
        }

        .fixed-back-btn {
            left: 30px;
        }

        .fixed-exit-btn {
            right: 30px;
        }

        .fixed-back-btn:hover, .fixed-exit-btn:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            background: rgba(255, 255, 255, 0.15);
        }

        /* Bot Assistant Styles */
        .bot-container {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 1000;
        }

        .bot-toggle {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            border: none;
            color: white;
            font-size: 2rem;
            cursor: pointer;
            box-shadow: 
                0 6px 25px rgba(108, 92, 231, 0.5),
                0 0 15px rgba(108, 92, 231, 0.6);
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
            animation: pulse 2s infinite;
        }

        .bot-toggle:hover {
            transform: scale(1.1) rotate(5deg);
            box-shadow: 
                0 8px 30px rgba(108, 92, 231, 0.7),
                0 0 20px rgba(108, 92, 231, 0.8);
        }

        .bot-assistant {
            position: absolute;
            bottom: 90px;
            right: 0;
            width: 350px;
            background: var(--card-bg);
            backdrop-filter: blur(20px);
            border-radius: var(--border-radius);
            box-shadow: var(--card-shadow);
            overflow: hidden;
            transform: translateY(20px) scale(0.95);
            opacity: 0;
            visibility: hidden;
            transition: var(--transition);
            border: 1px solid var(--card-glow);
        }

        .bot-assistant.active {
            transform: translateY(0) scale(1);
            opacity: 1;
            visibility: visible;
        }

        .bot-header {
            padding: 18px 25px;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--card-glow);
        }

        .bot-header h3 {
            font-size: 1.3rem;
            font-weight: 700;
        }

        .bot-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.3rem;
            cursor: pointer;
            transition: var(--transition);
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .bot-close:hover {
            transform: rotate(90deg);
            background: rgba(255, 255, 255, 0.1);
        }

        .bot-content {
            padding: 25px;
        }

        .bot-messages {
            margin-bottom: 25px;
            max-height: 220px;
            overflow-y: auto;
            padding-right: 10px;
        }

        .bot-messages::-webkit-scrollbar {
            width: 5px;
        }

        .bot-messages::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
        }

        .bot-message {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px 18px;
            border-radius: 15px;
            margin-bottom: 12px;
            border-left: 3px solid #00b894;
        }

        .bot-message p {
            margin: 0;
            line-height: 1.5;
            font-size: 0.95rem;
        }

        .bot-questions {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .bot-question {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            padding: 14px 18px;
            border-radius: 12px;
            color: white;
            text-align: left;
            cursor: pointer;
            transition: var(--transition);
            font-size: 0.95rem;
            width: 100%;
            border: 1px solid transparent;
        }

        .bot-question:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(5px);
            border-color: rgba(255, 255, 255, 0.1);
        }

        /* Music Toggle Styles */
        .music-toggle {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: var(--card-bg);
            border: 1px solid var(--card-glow);
            color: white;
            font-size: 1.4rem;
            cursor: pointer;
            backdrop-filter: blur(15px);
            box-shadow: var(--card-shadow);
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1001;
        }

        .music-toggle:hover {
            transform: scale(1.1);
            background: rgba(255, 255, 255, 0.15);
        }

        .music-toggle.playing {
            background: var(--accent-color);
            animation: musicPulse 2s infinite;
        }

        @keyframes musicPulse {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(253, 121, 168, 0.7);
            }
            50% {
                box-shadow: 0 0 0 10px rgba(253, 121, 168, 0);
            }
        }

        /* Typing animation */
        .typing-cursor {
            display: inline-block;
            width: 3px;
            height: 1em;
            background-color: white;
            margin-left: 2px;
            animation: blink 1s infinite;
            vertical-align: middle;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        /* Game Stats Styles */
        .stats-container {
            margin-top: 15px;
            padding: 15px;
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%);
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .stats-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .stats-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .stats-bar {
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            margin-bottom: 10px;
            overflow: hidden;
        }

        .stats-progress {
            height: 100%;
            border-radius: 4px;
            transition: width 0.5s ease;
        }

        .stats-progress.red { background: var(--red); }
        .stats-progress.green { background: var(--green); }
        .stats-progress.blue { background: var(--blue); }
        .stats-progress.yellow { background: var(--yellow); }

        /* Game History Styles */
        .history-container {
            margin-top: 15px;
            padding: 15px;
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%);
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.1);
            max-height: 150px;
            overflow-y: auto;
        }

        .history-item {
            font-size: 0.85rem;
            margin-bottom: 5px;
            padding: 5px;
            border-radius: 5px;
            background: rgba(255,255,255,0.05);
        }

        /* NEW: Confetti animation */
        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background-color: #f00;
            opacity: 0.8;
            z-index: 9999;
            animation: confetti-fall 5s linear forwards;
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(-100px) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }

        /* NEW: Player turn indicator */
        .player-turn-indicator {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 3px solid transparent;
            animation: turn-indicator 2s infinite;
            pointer-events: none;
        }

        @keyframes turn-indicator {
            0%, 100% { border-color: rgba(255, 255, 255, 0.5); transform: scale(1); }
            50% { border-color: rgba(255, 255, 255, 0.8); transform: scale(1.1); }
        }

        /* NEW: Token stacking */
        .token-stacked {
            animation: stack-pulse 1.5s infinite;
        }

        @keyframes stack-pulse {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        /* NEW: Achievement badges */
        .achievement-badge {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: var(--card-bg);
            backdrop-filter: blur(20px);
            padding: 20px;
            border-radius: 15px;
            box-shadow: var(--card-shadow);
            border: 1px solid var(--card-glow);
            text-align: center;
            z-index: 1002;
            transition: transform 0.5s ease;
        }

        .achievement-badge.show {
            transform: translate(-50%, -50%) scale(1);
        }

        .achievement-icon {
            font-size: 3rem;
            margin-bottom: 10px;
            color: gold;
        }

        /* NEW: Game speed controls */
        .speed-controls {
            display: flex;
            gap: 5px;
            margin: 10px 0;
        }

        .speed-btn {
            flex: 1;
            padding: 5px;
            font-size: 0.8rem;
        }

        /* NEW: Turn transition animation */
        .turn-transition {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.5s ease;
        }

        .turn-transition.active {
            opacity: 1;
            visibility: visible;
        }

        .turn-transition-content {
            background: var(--card-bg);
            backdrop-filter: blur(20px);
            padding: 30px 50px;
            border-radius: 15px;
            text-align: center;
            box-shadow: var(--card-shadow);
            border: 1px solid var(--card-glow);
            transform: scale(0.8);
            transition: transform 0.5s ease;
        }

        .turn-transition.active .turn-transition-content {
            transform: scale(1);
        }

        .turn-transition h3 {
            font-size: 2rem;
            margin-bottom: 10px;
            background: linear-gradient(to right, #a29bfe, #fd79a8, #00b894);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* responsive */
        @media (max-width: 900px) {
            .board-wrapper { flex-direction: column; align-items: center; }
            .game-ui { margin-left: 0; margin-top: 16px; width: 100%; max-width: 600px; }
            .ludo-board { width: 90vw; height: 90vw; max-width: 500px; max-height: 500px; }
            
            .fixed-back-btn, .fixed-exit-btn {
                top: 20px;
                width: 50px;
                height: 50px;
                font-size: 1.2rem;
            }
            
            .fixed-back-btn {
                left: 20px;
            }
            
            .fixed-exit-btn {
                right: 20px;
            }
            
            .music-toggle {
                bottom: 20px;
                left: 20px;
                width: 55px;
                height: 55px;
            }
            
            .bot-container {
                bottom: 20px;
                right: 20px;
            }
            
            .bot-assistant {
                width: 300px;
            }
        }

        @media (max-width: 480px) {
            .ludo-board { width: 95vw; height: 95vw; }
            
            .fixed-back-btn, .fixed-exit-btn {
                top: 15px;
                width: 45px;
                height: 45px;
                font-size: 1.1rem;
            }
            
            .fixed-back-btn {
                left: 15px;
            }
            
            .fixed-exit-btn {
                right: 15px;
            }
            
            .music-toggle {
                bottom: 15px;
                left: 15px;
                width: 50px;
                height: 50px;
            }
            
            .bot-container {
                bottom: 15px;
                right: 15px;
            }
            
            .bot-assistant {
                width: 280px;
            }
            
            .turn-transition-content {
                padding: 20px 30px;
            }
            
            .turn-transition h3 {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <!-- Background Music -->
    <audio id="backgroundMusic" loop>
        <source src="https://assets.mixkit.co/music/preview/mixkit-game-show-suspense-waiting-667.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    
    <!-- Game Sounds -->
    <audio id="moveSound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-plastic-bubble-click-1124.mp3" type="audio/mpeg">
    </audio>
    <audio id="diceSound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-dice-roll-1998.mp3" type="audio/mpeg">
    </audio>
    <audio id="captureSound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-jump-coin-216.mp3" type="audio/mpeg">
    </audio>
    <audio id="winSound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-winning-chimes-2015.mp3" type="audio/mpeg">
    </audio>

    <!-- Turn Transition Overlay -->
    <div class="turn-transition" id="turnTransition">
        <div class="turn-transition-content">
            <h3 id="turnTransitionText">Player's Turn</h3>
            <p>Get ready!</p>
        </div>
    </div>

    <!-- Fixed Navigation Buttons -->
    <button class="fixed-back-btn" id="btnBack">
        <i class="fas fa-arrow-left"></i>
    </button>
    
    <button class="fixed-exit-btn" id="btnExit">
        <i class="fas fa-times"></i>
    </button>
    
    <!-- Music Toggle -->
    <button class="music-toggle" id="musicToggle">
        <i class="fas fa-volume-up"></i>
    </button>

    <!-- Bot Assistant -->
    <div class="bot-container">
        <button class="bot-toggle" id="botToggle">
            <i class="fas fa-question-circle"></i>
        </button>
        <div class="bot-assistant" id="botAssistant">
            <div class="bot-header">
                <h3>MO11 - <a href="https://www.instagram.com/mo_little11?igsh=MTZsdWhpeXg5ZGttYQ%3D%3D&utm_source=qr" style="color: #fd79a8; text-decoration: none;">#1011</a></h3>
                <button class="bot-close" id="botClose">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="bot-content">
                <div class="bot-messages">
                    <div class="bot-message">
                        <p>Need help with Ludo? I can assist you!</p>
                    </div>
                </div>
                <div class="bot-questions">
                    <button class="bot-question" data-question="ludo-rules">
                        <span>What are the basic rules?</span>
                    </button>
                    <button class="bot-question" data-question="ludo-strategy">
                        <span>Winning strategies</span>
                    </button>
                    <button class="bot-question" data-question="ludo-tokens">
                        <span>How do tokens work?</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Achievement Badge -->
    <div class="achievement-badge" id="achievementBadge">
        <div class="achievement-icon">
            <i class="fas fa-trophy"></i>
        </div>
        <h4 id="achievementTitle">Achievement Unlocked!</h4>
        <p id="achievementDesc">Description of the achievement</p>
    </div>

    <div class="container">
        <h1 class="text-center mb-4">Ludo Game — Milah Special</h1>
        
        <div class="board-wrapper">
            <div class="ludo-board-container">
                <div class="ludo-board" id="ludoBoard">
                    <div class="home red">
                        <div class="start-area" style="--color: var(--red);">
                            <div class="token-hole" style="--color: var(--red); --color-dark: #C62828;"></div>
                            <div class="token-hole" style="--color: var(--red); --color-dark: #C62828;"></div>
                            <div class="token-hole" style="--color: var(--red); --color-dark: #C62828;"></div>
                            <div class="token-hole" style="--color: var(--red); --color-dark: #C62828;"></div>
                        </div>
                    </div>
                    <div class="home green">
                        <div class="start-area" style="--color: var(--green);">
                            <div class="token-hole" style="--color: var(--green); --color-dark: #2E7D32;"></div>
                            <div class="token-hole" style="--color: var(--green); --color-dark: #2E7D32;"></div>
                            <div class="token-hole" style="--color: var(--green); --color-dark: #2E7D32;"></div>
                            <div class="token-hole" style="--color: var(--green); --color-dark: #2E7D32;"></div>
                        </div>
                    </div>
                    <div class="home blue">
                        <div class="start-area" style="--color: var(--blue);">
                            <div class="token-hole" style="--color: var(--blue); --color-dark: #1565C0;"></div>
                            <div class="token-hole" style="--color: var(--blue); --color-dark: #1565C0;"></div>
                            <div class="token-hole" style="--color: var(--blue); --color-dark: #1565C0;"></div>
                            <div class="token-hole" style="--color: var(--blue); --color-dark: #1565C0;"></div>
                        </div>
                    </div>
                    <div class="home yellow">
                        <div class="start-area" style="--color: var(--yellow);">
                            <div class="token-hole" style="--color: var(--yellow); --color-dark: #F9A825;"></div>
                            <div class="token-hole" style="--color: var(--yellow); --color-dark: #F9A825;"></div>
                            <div class="token-hole" style="--color: var(--yellow); --color-dark: #F9A825;"></div>
                            <div class="token-hole" style="--color: var(--yellow); --color-dark: #F9A825;"></div>
                        </div>
                    </div>

                    <!-- cells (will be generated by script) -->

                    <div class="center-home">
                        <div class="center-triangle red"></div>
                        <div class="center-triangle green"></div>
                        <div class="center-triangle blue"></div>
                        <div class="center-triangle yellow"></div>
                    </div>
                </div>
            </div>

            <div class="game-ui">
                <h3>Game Controls</h3>
                <p class="small">Mode: <strong id="modeLabel">Local + AI</strong></p>

                <div class="mb-3">
                    <div class="d-flex gap-2 align-items-center">
                        <div id="dice" class="dice" title="Click to roll">1</div>
                        <div>
                            <div><strong>Turn:</strong> <span id="turnDisplay">-</span></div>
                            <div><strong>Last roll:</strong> <span id="lastRoll">-</span></div>
                            <div><strong>Status:</strong> <span id="gameStatus">Not started</span></div>
                        </div>
                    </div>
                </div>

                <div class="status-message" id="statusMessage">
                    Click "New Game" to start playing!
                </div>

                <div class="mb-2">
                    <button id="startBtn" class="btn btn-success">New Game</button>
                    <button id="toggleAiBtn" class="btn btn-secondary">Toggle AI</button>
                    <button id="statsBtn" class="btn btn-info">Show Stats</button>
                </div>

                <!-- NEW: Game Speed Controls -->
                <div class="speed-controls">
                    <button class="btn btn-sm btn-outline-light speed-btn" data-speed="slow">Slow</button>
                    <button class="btn btn-sm btn-outline-light speed-btn active" data-speed="normal">Normal</button>
                    <button class="btn btn-sm btn-outline-light speed-btn" data-speed="fast">Fast</button>
                </div>

                <div class="player-controls">
                    <div class="player-control">
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="redAI" checked>
                            <label class="form-check-label" for="redAI">Red AI</label>
                        </div>
                    </div>
                    <div class="player-control">
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="greenAI" checked>
                            <label class="form-check-label" for="greenAI">Green AI</label>
                        </div>
                    </div>
                    <div class="player-control">
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="blueAI" checked>
                            <label class="form-check-label" for="blueAI">Blue AI</label>
                        </div>
                    </div>
                    <div class="player-control">
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="yellowAI" checked>
                            <label class="form-check-label" for="yellowAI">Yellow AI</label>
                        </div>
                    </div>
                </div>

                <div class="mb-2">
                    <div><strong>Players:</strong></div>
                    <ul id="playersList" class="list-group"></ul>
                </div>

                <div class="stats-container" id="statsContainer" style="display: none;">
                    <div class="stats-header">
                        <h5>Game Statistics</h5>
                        <button class="btn btn-sm btn-outline-light" id="closeStats">Close</button>
                    </div>
                    <div id="statsContent"></div>
                </div>

                <div class="history-container" id="historyContainer" style="display: none;">
                    <div class="stats-header">
                        <h5>Game History</h5>
                        <button class="btn btn-sm btn-outline-light" id="closeHistory">Close</button>
                    </div>
                    <div id="historyContent"></div>
                </div>

                <div class="winner-list" id="winnerList" style="display: none;">
                    <h5>Winners:</h5>
                    <div id="winnerItems"></div>
                </div>

                <div class="mb-2 small">
                    <strong>Game Rules:</strong>
                    <ul>
                        <li>Roll a 6 to move a token out of home</li>
                        <li>Land on an opponent's token to send it home</li>
                        <li>Exact roll needed to enter the center</li>
                        <li>Three 6s in a row ends your turn</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- Tokens container (absolute over board) -->
    <div id="tokensLayer" style="position: absolute; left: 20px; top: 20px; pointer-events: none;"></div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const board = document.querySelector('#ludoBoard');
            const tokensLayer = document.getElementById('tokensLayer');
            const diceEl = document.getElementById('dice');
            const turnDisplay = document.getElementById('turnDisplay');
            const lastRollEl = document.getElementById('lastRoll');
            const playersList = document.getElementById('playersList');
            const statusMessage = document.getElementById('statusMessage');
            const gameStatus = document.getElementById('gameStatus');
            const winnerList = document.getElementById('winnerList');
            const winnerItems = document.getElementById('winnerItems');
            const statsContainer = document.getElementById('statsContainer');
            const statsContent = document.getElementById('statsContent');
            const historyContainer = document.getElementById('historyContainer');
            const historyContent = document.getElementById('historyContent');
            const achievementBadge = document.getElementById('achievementBadge');
            const achievementTitle = document.getElementById('achievementTitle');
            const achievementDesc = document.getElementById('achievementDesc');
            const turnTransition = document.getElementById('turnTransition');
            const turnTransitionText = document.getElementById('turnTransitionText');
            
            // Audio elements
            const backgroundMusic = document.getElementById('backgroundMusic');
            const moveSound = document.getElementById('moveSound');
            const diceSound = document.getElementById('diceSound');
            const captureSound = document.getElementById('captureSound');
            const winSound = document.getElementById('winSound');
            
            // Game settings
            let gameSpeed = 300; // Default speed in ms
            let achievements = {
                firstWin: false,
                threeSixes: false,
                perfectGame: false,
                comeback: false
            };
            
            // Board generation
            const homePaths = {
                red:    [{r: 8, c: 2}, {r: 8, c: 3}, {r: 8, c: 4}, {r: 8, c: 5}, {r: 8, c: 6}, {r: 8, c: 7}],
                green:  [{r: 2, c: 8}, {r: 3, c: 8}, {r: 4, c: 8}, {r: 5, c: 8}, {r: 6, c: 8}, {r: 7, c: 8}],
                blue:   [{r: 14, c: 8}, {r: 13, c: 8}, {r: 12, c: 8}, {r: 11, c: 8}, {r: 10, c: 8}, {r: 9, c: 8}],
                yellow: [{r: 8, c: 14}, {r: 8, c: 13}, {r: 8, c: 12}, {r: 8, c: 11}, {r: 8, c: 10}, {r: 8, c: 9}]
            };

            const startSquares = { red: {r:7,c:2}, green:{r:2,c:9}, blue:{r:14,c:7}, yellow:{r:9,c:14} };
            const safeSquares = [ {r:7,c:4,color:'red'}, {r:4,c:7,color:'green'}, {r:12,c:7,color:'blue'}, {r:7,c:12,color:'yellow'} ];

            const cellMap = {}; // key "r,c" -> element

            for (let i = 1; i <= 15; i++) {
                for (let j = 1; j <= 15; j++) {
                    if (
                        (i <= 6 && j <= 6) || (i <= 6 && j >= 10) ||
                        (i >= 10 && j <= 6) || (i >= 10 && j >= 10) ||
                        (i >= 7 && i <= 9 && j >= 7 && j <= 9)
                    ) {
                        continue;
                    }

                    let cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.r = i; cell.dataset.c = j;
                    cell.style.gridArea = `${i} / ${j} / span 1 / span 1`;

                    // Add Start Square class
                    if (i === startSquares.red.r && j === startSquares.red.c) cell.classList.add('start-square', 'red');
                    if (i === startSquares.green.r && j === startSquares.green.c) cell.classList.add('start-square', 'green');
                    if (i === startSquares.blue.r && j === startSquares.blue.c) cell.classList.add('start-square', 'blue');
                    if (i === startSquares.yellow.r && j === startSquares.yellow.c) cell.classList.add('start-square', 'yellow');

                    // Add Home Run Path class
                    for (const color in homePaths) {
                        if (homePaths[color].some(coord => coord.r === i && coord.c === j)) {
                            cell.classList.add('home-path', color);
                        }
                    }

                    // Add Safe Square class
                    const safe = safeSquares.find(s => s.r === i && s.c === j);
                    if (safe) cell.classList.add('safe-square', safe.color);

                    board.appendChild(cell);
                    cellMap[`${i},${j}`] = cell;
                }
            }

            // Position tokens layer
            function positionTokensLayer() {
                const boardRect = board.getBoundingClientRect();
                tokensLayer.style.width = boardRect.width + 'px';
                tokensLayer.style.height = boardRect.height + 'px';
                tokensLayer.style.left = (boardRect.left) + 'px';
                tokensLayer.style.top = (boardRect.top) + 'px';
            }

            positionTokensLayer();
            window.addEventListener('resize', positionTokensLayer);

            // CORRECTED TRACK DEFINITION - Standard Ludo path
            // This is the main track that all players follow (clockwise)
            const track = [
                // Red starting path (from red start to first corner)
                {r:7,c:2}, {r:7,c:3}, {r:7,c:4}, {r:7,c:5}, {r:7,c:6},
                // Up to top-left corner
                {r:6,c:6}, {r:5,c:6}, {r:4,c:6}, {r:3,c:6}, {r:2,c:6},
                // Across top
                {r:2,c:7}, {r:2,c:8}, {r:2,c:9}, {r:2,c:10}, {r:2,c:11},
                // Down to top-right corner
                {r:3,c:11}, {r:4,c:11}, {r:5,c:11}, {r:6,c:11}, {r:7,c:11},
                // Across middle-right
                {r:8,c:11}, {r:9,c:11}, {r:10,c:11}, {r:11,c:11}, {r:12,c:11},
                // Across bottom-right
                {r:12,c:10}, {r:12,c:9}, {r:12,c:8}, {r:12,c:7}, {r:12,c:6},
                // Up to bottom-left corner
                {r:11,c:6}, {r:10,c:6}, {r:9,c:6}, {r:8,c:6}, {r:8,c:5},
                // Across bottom-left
                {r:8,c:4}, {r:8,c:3}, {r:8,c:2}, {r:9,c:2}, {r:10,c:2},
                {r:11,c:2}, {r:12,c:2}, {r:13,c:2}, {r:14,c:2}, {r:14,c:3},
                {r:14,c:4}, {r:14,c:5}, {r:14,c:6}, {r:14,c:7}
            ];
            
            const TRACK_LEN = track.length;

            // CORRECTED: Find starting positions for each color
            const startIndex = {
                red: 0,    // Red starts at position 0
                green: 13, // Green starts at position 13
                blue: 26,  // Blue starts at position 26
                yellow: 39 // Yellow starts at position 39
            };

            // Game state
            const COLORS = ['red','green','blue','yellow'];
            const game = {
                players: [ 
                    {color:'red',isAI:false}, 
                    {color:'green',isAI:true}, 
                    {color:'blue',isAI:true}, 
                    {color:'yellow',isAI:true} 
                ],
                currentPlayerIdx: 0,
                consecutiveSixes: 0,
                lastRoll: null,
                tokens: {},
                winnerOrder: [],
                gameActive: false,
                diceRolling: false,
                waitingForTokenSelection: false,
                selectedToken: null,
                gameHistory: [],
                stats: {
                    rolls: {red:0, green:0, blue:0, yellow:0},
                    moves: {red:0, green:0, blue:0, yellow:0},
                    captures: {red:0, green:0, blue:0, yellow:0},
                    sixes: {red:0, green:0, blue:0, yellow:0}
                }
            };

            // Token management
            let tokenIdCounter = 0;
            function createTokens() {
                game.tokens = {};
                
                // CORRECTED: Home positions for tokens - these are the positions inside the start areas
                const homePositions = { 
                    red: [
                        {r:3,c:3}, {r:3,c:4}, 
                        {r:4,c:3}, {r:4,c:4}
                    ],
                    green: [
                        {r:3,c:12}, {r:3,c:13}, 
                        {r:4,c:12}, {r:4,c:13}
                    ],
                    blue: [
                        {r:12,c:3}, {r:12,c:4}, 
                        {r:13,c:3}, {r:13,c:4}
                    ],
                    yellow: [
                        {r:12,c:12}, {r:12,c:13}, 
                        {r:13,c:12}, {r:13,c:13}
                    ]
                };

                for (const color of COLORS){
                    for (let t=0;t<4;t++){
                        const id = `t_${color[0]}${t}`;
                        const token = {
                            id, color, index:-1,
                            finished: false,
                            element: createTokenElement(id,color)
                        };
                        game.tokens[id]=token;
                        const homeCoord = homePositions[color][t]; // Use the specific position for this token
                        placeTokenElement(token, homeCoord);
                    }
                }
            }

            function createTokenElement(id,color){
                const el = document.createElement('div');
                el.className = `token ${color}`;
                el.id = id;
                el.innerText = id.split('_')[1].slice(1);
                el.style.pointerEvents = 'auto';
                el.addEventListener('click', handleTokenClick);
                tokensLayer.appendChild(el);
                return el;
            }

            // Handle token click for human players
            function handleTokenClick(e) {
                if (!game.gameActive || game.diceRolling) return;
                
                const player = game.players[game.currentPlayerIdx];
                if (player.isAI) return;
                
                const tokenId = e.currentTarget.id;
                const token = game.tokens[tokenId];
                
                if (token.color !== player.color) return;
                
                if (game.waitingForTokenSelection) {
                    // If we're waiting for token selection, select this token
                    game.selectedToken = token;
                    game.waitingForTokenSelection = false;
                    moveSelectedToken();
                } else if (game.lastRoll === 6 && token.index === -1) {
                    // If we rolled a 6 and clicked on a token in home, move it out
                    game.selectedToken = token;
                    moveSelectedToken();
                }
            }

            // Convert board cell (r,c) to pixel coordinates
            function cellCenterPixel(r,c){
                const cell = cellMap[`${r},${c}`];
                if (!cell) return null;
                const rect = cell.getBoundingClientRect();
                const layerRect = tokensLayer.getBoundingClientRect();
                return { 
                    x: (rect.left + rect.right)/2 - layerRect.left - 18, 
                    y: (rect.top + rect.bottom)/2 - layerRect.top - 18 
                };
            }

            // CORRECTED: Place token element with proper path calculation
            function placeTokenElement(token, homeCoord){
                const el = token.element;
                if (token.index === -1){
                    // Token is in home
                    const px = cellCenterPixel(homeCoord.r, homeCoord.c);
                    if (px) {
                        el.style.left = px.x + 'px';
                        el.style.top = px.y + 'px';
                    }
                } else if (token.index >= TRACK_LEN) {
                    // Token is in home path
                    const color = token.color;
                    const hp = homePaths[color];
                    const pos = hp[token.index - TRACK_LEN];
                    if (pos){
                        const px = cellCenterPixel(pos.r,pos.c);
                        if (px){ 
                            el.style.left = px.x + 'px'; 
                            el.style.top = px.y + 'px'; 
                        }
                    }
                } else {
                    // Token is on the main track
                    // CORRECTED: Calculate position based on player's starting point
                    const playerStartIndex = startIndex[token.color];
                    const actualIndex = (playerStartIndex + token.index) % TRACK_LEN;
                    const pos = track[actualIndex];
                    if (pos){
                        const px = cellCenterPixel(pos.r,pos.c);
                        if (px){ 
                            el.style.left = px.x + 'px'; 
                            el.style.top = px.y + 'px'; 
                        }
                    }
                }
                
                // Update token appearance based on state
                if (token.finished) {
                    el.classList.add('finished');
                } else {
                    el.classList.remove('finished');
                }
            }

            // CORRECTED: Move token with proper path following
            async function moveTokenBy(token, steps){
                if (token.finished) return;

                token.element.classList.add('moving');

                if (token.index === -1){
                    if (steps === 6){
                        token.index = 0;
                        placeTokenElement(token);
                        await sleep(gameSpeed);
                        playSound(moveSound);
                        // Update stats
                        game.stats.moves[token.color]++;
                    }
                    token.element.classList.remove('moving');
                    return;
                }

                for (let s=0; s<steps; s++){
                    token.index++;
                    
                    // Check if token has entered home path
                    if (token.index === TRACK_LEN) {
                        // Token is at the entrance to home path
                        // Check if exact roll is needed to enter home path
                        if (s < steps - 1) {
                            // Not exact roll, can't enter home path yet
                            token.index = TRACK_LEN - 1;
                            break;
                        }
                    }
                    
                    if (token.index === TRACK_LEN + homePaths[token.color].length){
                        token.finished = true;
                        token.index = TRACK_LEN + homePaths[token.color].length - 1;
                        if (!game.winnerOrder.includes(token.color)) {
                            game.winnerOrder.push(token.color);
                            updateWinnerList();
                            playSound(winSound);
                            createConfetti();
                            checkAchievements(token.color);
                        }
                        placeTokenElement(token);
                        break;
                    }
                    placeTokenElement(token);
                    await sleep(gameSpeed);
                    // Update stats
                    game.stats.moves[token.color]++;
                }
                
                token.element.classList.remove('moving');
            }

            function sleep(ms){ return new Promise(res=>setTimeout(res, ms)); }

            // Play sound function
            function playSound(sound) {
                if (sound) {
                    sound.currentTime = 0;
                    sound.play().catch(e => console.log("Sound play prevented:", e));
                }
            }

            // NEW: Create confetti animation
            function createConfetti() {
                const colors = ['#f94144', '#f3722c', '#f8961e', '#f9c74f', '#90be6d', '#43aa8b', '#577590'];
                for (let i = 0; i < 100; i++) {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + 'vw';
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.width = Math.random() * 10 + 5 + 'px';
                    confetti.style.height = Math.random() * 10 + 5 + 'px';
                    confetti.style.animationDuration = Math.random() * 3 + 2 + 's';
                    document.body.appendChild(confetti);
                    
                    setTimeout(() => {
                        confetti.remove();
                    }, 5000);
                }
            }

            // NEW: Check for achievements
            function checkAchievements(color) {
                const player = game.players.find(p => p.color === color);
                
                // First win achievement
                if (!achievements.firstWin && game.winnerOrder.length === 1) {
                    achievements.firstWin = true;
                    showAchievement("First Victory!", `${color.charAt(0).toUpperCase() + color.slice(1)} won their first game!`);
                }
                
                // Three sixes in a row achievement
                if (!achievements.threeSixes && game.consecutiveSixes >= 3) {
                    achievements.threeSixes = true;
                    showAchievement("Lucky Streak!", "Rolled three 6s in a row!");
                }
                
                // Perfect game achievement (all tokens home without being captured)
                const playerTokens = Object.values(game.tokens).filter(t => t.color === color);
                const captures = game.stats.captures[color];
                if (!achievements.perfectGame && playerTokens.every(t => t.finished) && captures === 0) {
                    achievements.perfectGame = true;
                    showAchievement("Perfect Game!", `${color.charAt(0).toUpperCase() + color.slice(1)} finished without any captures!`);
                }
            }

            // NEW: Show achievement badge
            function showAchievement(title, description) {
                achievementTitle.textContent = title;
                achievementDesc.textContent = description;
                achievementBadge.classList.add('show');
                
                setTimeout(() => {
                    achievementBadge.classList.remove('show');
                }, 3000);
            }

            // NEW: Show turn transition
            async function showTurnTransition(player) {
                const playerName = player.color.charAt(0).toUpperCase() + player.color.slice(1);
                const playerType = player.isAI ? "AI" : "Player";
                
                turnTransitionText.textContent = `${playerName} ${playerType}'s Turn`;
                turnTransition.classList.add('active');
                
                await sleep(1000);
                
                turnTransition.classList.remove('active');
                await sleep(500);
            }

            // UI Updates
            function updatePlayersUI(){
                playersList.innerHTML = '';
                game.players.forEach((p,idx)=>{
                    const li = document.createElement('li');
                    li.className = `list-group-item d-flex justify-content-between align-items-center ${idx===game.currentPlayerIdx ? 'active' : ''}`;
                    li.innerHTML = `
                        <span>${p.color.charAt(0).toUpperCase() + p.color.slice(1)}</span>
                        <span class="badge ${p.isAI ? 'bg-secondary' : 'bg-primary'} rounded-pill">${p.isAI ? 'AI' : 'Human'}</span>
                    `;
                    playersList.appendChild(li);
                });
            }

            async function nextPlayer() {
                game.currentPlayerIdx = (game.currentPlayerIdx + 1) % game.players.length;
                game.consecutiveSixes = 0;
                updatePlayersUI();
                updateTurnDisplay();
                
                // Show turn transition
                const player = game.players[game.currentPlayerIdx];
                await showTurnTransition(player);
            }

            function updateTurnDisplay(){
                const p = game.players[game.currentPlayerIdx];
                turnDisplay.innerText = p.color.charAt(0).toUpperCase() + p.color.slice(1) + (p.isAI? ' (AI)':'' );
                gameStatus.innerText = game.gameActive ? (p.isAI ? 'AI thinking...' : 'Your turn') : 'Game over';
            }

            function updateStatusMessage(message) {
                statusMessage.textContent = message;
            }

            function updateWinnerList() {
                if (game.winnerOrder.length > 0) {
                    winnerList.style.display = 'block';
                    winnerItems.innerHTML = '';
                    
                    game.winnerOrder.forEach((color, index) => {
                        const winnerItem = document.createElement('div');
                        winnerItem.className = 'winner-item';
                        winnerItem.innerHTML = `
                            <div class="winner-color" style="background-color: ${getColorValue(color)}"></div>
                            <span>${index + 1}. ${color.charAt(0).toUpperCase() + color.slice(1)}</span>
                        `;
                        winnerItems.appendChild(winnerItem);
                    });
                }
            }

            function getColorValue(color) {
                switch(color) {
                    case 'red': return '#E53935';
                    case 'green': return '#43A047';
                    case 'blue': return '#1E88E5';
                    case 'yellow': return '#FDD835';
                    default: return '#000';
                }
            }

            // Dice rolling with animation
            async function rollDice(){
                game.diceRolling = true;
                diceEl.classList.add('rolling');
                playSound(diceSound);
                
                for (let i=0;i<10;i++){ 
                    diceEl.innerText = Math.floor(Math.random()*6)+1; 
                    await sleep(50); 
                }
                
                const val = Math.floor(Math.random()*6)+1;
                diceEl.innerText = val;
                diceEl.classList.remove('rolling');
                game.lastRoll = val; 
                lastRollEl.innerText = val;
                game.diceRolling = false;
                
                // Update stats
                const player = game.players[game.currentPlayerIdx];
                game.stats.rolls[player.color]++;
                if (val === 6) {
                    game.stats.sixes[player.color]++;
                }
                
                return val;
            }

            // IMPROVED AI: Token selection logic
            function chooseTokenToMove(color, roll){
                const tokens = Object.values(game.tokens).filter(t=>t.color===color && !t.finished);
                const inHome = tokens.filter(t=>t.index===-1);
                
                // If we can move a token out of home, do that
                if (roll===6 && inHome.length>0) return inHome[0];
                
                // Otherwise, choose the token that's farthest along
                const onTrack = tokens.filter(t=>t.index>=0);
                if (onTrack.length===0) return null;
                
                // IMPROVED AI: Try to capture opponent tokens if possible
                for (const token of onTrack) {
                    const newIndex = token.index + roll;
                    if (newIndex < TRACK_LEN) {
                        const playerStartIndex = startIndex[token.color];
                        const actualIndex = (playerStartIndex + newIndex) % TRACK_LEN;
                        const pos = track[actualIndex];
                        
                        // Check if this position would capture an opponent
                        for (const t of Object.values(game.tokens)){
                            if (t.color===color || t.index<0) continue;
                            
                            let tcoord;
                            if (t.index >= TRACK_LEN) {
                                const idx = t.index - TRACK_LEN; 
                                tcoord = homePaths[t.color][idx];
                            } else {
                                const playerStartIndex = startIndex[t.color];
                                const actualIndex = (playerStartIndex + t.index) % TRACK_LEN;
                                tcoord = track[actualIndex];
                            }
                            
                            if (tcoord && tcoord.r===pos.r && tcoord.c===pos.c){
                                // This move would capture an opponent - prioritize it
                                return token;
                            }
                        }
                    }
                }
                
                // IMPROVED AI: Try to move tokens that are close to finishing
                const closeToFinish = onTrack.filter(t => {
                    const remaining = (TRACK_LEN + homePaths[t.color].length) - t.index;
                    return remaining <= 6 && remaining >= roll;
                });
                
                if (closeToFinish.length > 0) {
                    return closeToFinish[0];
                }
                
                // Otherwise, choose the token that's farthest along
                onTrack.sort((a,b)=> (b.index - a.index));
                return onTrack[0];
            }

            // CORRECTED: Check for captures with proper position calculation
            function checkCaptures(movedToken){
                if (movedToken.index<0) return;
                
                let coord;
                if (movedToken.index >= TRACK_LEN){
                    const idx = movedToken.index - TRACK_LEN;
                    coord = homePaths[movedToken.color][idx];
                } else {
                    // Calculate the actual position on the track
                    const playerStartIndex = startIndex[movedToken.color];
                    const actualIndex = (playerStartIndex + movedToken.index) % TRACK_LEN;
                    coord = track[actualIndex];
                }
                
                if (!coord) return;
                
                const safe = safeSquares.find(s => s.r===coord.r && s.c===coord.c);
                if (safe) return;
                
                for (const t of Object.values(game.tokens)){
                    if (t.color===movedToken.color) continue;
                    if (t.index<0) continue;
                    
                    let tcoord;
                    if (t.index >= TRACK_LEN) {
                        const idx = t.index - TRACK_LEN; 
                        tcoord = homePaths[t.color][idx];
                    } else {
                        // Calculate the actual position on the track
                        const playerStartIndex = startIndex[t.color];
                        const actualIndex = (playerStartIndex + t.index) % TRACK_LEN;
                        tcoord = track[actualIndex];
                    }
                    
                    if (!tcoord) continue;
                    if (tcoord.r===coord.r && tcoord.c===coord.c){
                        // Capture opponent token
                        t.index = -1;
                        placeTokenElement(t);
                        updateStatusMessage(`${movedToken.color.charAt(0).toUpperCase() + movedToken.color.slice(1)} captured ${t.color}'s token!`);
                        playSound(captureSound);
                        // Update stats
                        game.stats.captures[movedToken.color]++;
                        
                        // Add to game history
                        addToHistory(`${movedToken.color} captured ${t.color}'s token`);
                    }
                }
            }

            // Highlight movable tokens
            function highlightMovableTokens(player, roll) {
                // Remove highlights from all tokens
                Object.values(game.tokens).forEach(token => {
                    token.element.classList.remove('movable');
                });
                
                // Highlight movable tokens for current player
                const tokens = Object.values(game.tokens).filter(t => t.color === player.color && !t.finished);
                tokens.forEach(token => {
                    if (token.index === -1 && roll === 6) {
                        token.element.classList.add('movable');
                    } else if (token.index >= 0) {
                        const newIndex = token.index + roll;
                        const maxIndex = TRACK_LEN + homePaths[token.color].length - 1;
                        if (newIndex <= maxIndex) {
                            token.element.classList.add('movable');
                        }
                    }
                });
            }

            // Add to game history
            function addToHistory(message) {
                const player = game.players[game.currentPlayerIdx];
                const historyItem = {
                    player: player.color,
                    message: message,
                    roll: game.lastRoll,
                    timestamp: new Date().toLocaleTimeString()
                };
                game.gameHistory.unshift(historyItem);
                
                // Keep only last 20 items
                if (game.gameHistory.length > 20) {
                    game.gameHistory.pop();
                }
                
                updateHistoryDisplay();
            }

            // Update history display
            function updateHistoryDisplay() {
                historyContent.innerHTML = '';
                game.gameHistory.forEach(item => {
                    const historyItem = document.createElement('div');
                    historyItem.className = 'history-item';
                    historyItem.innerHTML = `
                        <span class="badge bg-${item.player} me-1">${item.player.charAt(0).toUpperCase()}</span>
                        ${item.message} (Roll: ${item.roll}) 
                        <small class="text-muted ms-1">${item.timestamp}</small>
                    `;
                    historyContent.appendChild(historyItem);
                });
            }

            // Update stats display
            function updateStatsDisplay() {
                statsContent.innerHTML = '';
                
                COLORS.forEach(color => {
                    const statsItem = document.createElement('div');
                    statsItem.className = 'mb-3';
                    
                    const player = game.players.find(p => p.color === color);
                    const isActive = player && game.currentPlayerIdx === game.players.indexOf(player);
                    
                    statsItem.innerHTML = `
                        <div class="d-flex justify-content-between align-items-center mb-1">
                            <span class="fw-bold ${isActive ? 'text-warning' : ''}">${color.charAt(0).toUpperCase() + color.slice(1)}</span>
                            <span class="badge ${player && player.isAI ? 'bg-secondary' : 'bg-primary'}">${player && player.isAI ? 'AI' : 'Human'}</span>
                        </div>
                        <div class="stats-item">
                            <span>Rolls:</span>
                            <span>${game.stats.rolls[color]}</span>
                        </div>
                        <div class="stats-item">
                            <span>Moves:</span>
                            <span>${game.stats.moves[color]}</span>
                        </div>
                        <div class="stats-item">
                            <span>Captures:</span>
                            <span>${game.stats.captures[color]}</span>
                        </div>
                        <div class="stats-item">
                            <span>Sixes:</span>
                            <span>${game.stats.sixes[color]}</span>
                        </div>
                        <div class="stats-bar">
                            <div class="stats-progress ${color}" style="width: ${(game.stats.moves[color] / (game.stats.rolls[color] * 6)) * 100 || 0}%"></div>
                        </div>
                    `;
                    
                    statsContent.appendChild(statsItem);
                });
            }

            // Move selected token
            async function moveSelectedToken() {
                if (!game.selectedToken) return;
                
                const player = game.players[game.currentPlayerIdx];
                const token = game.selectedToken;
                const roll = game.lastRoll;
                
                // Add to game history
                addToHistory(`moved token ${token.id.split('_')[1].slice(1)}`);
                
                // Remove highlights
                Object.values(game.tokens).forEach(token => {
                    token.element.classList.remove('movable');
                });
                
                await moveTokenBy(token, roll);
                checkCaptures(token);

                // Check if player has won
                const remaining = Object.values(game.tokens).filter(t=>t.color===player.color && !t.finished);
                if (remaining.length===0){
                    updateStatusMessage(`${player.color.charAt(0).toUpperCase() + player.color.slice(1)} has won!`);
                    if (!game.winnerOrder.includes(player.color)) {
                        game.winnerOrder.push(player.color);
                        updateWinnerList();
                    }
                    
                    // Check if game is over
                    if (game.winnerOrder.length >= 3) {
                        game.gameActive = false;
                        updateStatusMessage("Game Over! " + game.winnerOrder[0].charAt(0).toUpperCase() + 
                            game.winnerOrder[0].slice(1) + " is the winner!");
                        return;
                    }
                }

                if (roll===6){
                    game.consecutiveSixes++;
                    if (game.consecutiveSixes>=3){
                        updateStatusMessage(`${player.color.charAt(0).toUpperCase() + player.color.slice(1)} rolled three 6s in a row! Turn lost.`);
                        game.consecutiveSixes = 0;
                        nextPlayer();
                        return;
                    }
                    
                    updateStatusMessage(`${player.color.charAt(0).toUpperCase() + player.color.slice(1)} rolled a 6! Extra turn.`);
                    
                    if (player.isAI){ 
                        await sleep(800); 
                        await playerTurn(); 
                        return; 
                    } else { 
                        updatePlayersUI(); 
                        return; 
                    }
                }

                await nextPlayer();
            }

            // Player turn logic
            async function playerTurn(){
                if (!game.gameActive) return;
                
                updatePlayersUI(); 
                updateTurnDisplay();
                
                const player = game.players[game.currentPlayerIdx];
                const isAI = player.isAI;
                const roll = await rollDice();
                game.lastRoll = roll;
                
                updateStatusMessage(`${player.color.charAt(0).toUpperCase() + player.color.slice(1)} rolled a ${roll}`);
                addToHistory(`rolled a ${roll}`);
                
                // Gather movable tokens
                const tokens = Object.values(game.tokens).filter(t=>t.color===player.color && !t.finished);
                const movable = tokens.filter(t => {
                    if (t.index === -1) return roll===6;
                    const newIndex = t.index + roll;
                    const maxIndex = TRACK_LEN + homePaths[t.color].length - 1;
                    return newIndex <= maxIndex;
                });

                if (movable.length===0){
                    updateStatusMessage(`${player.color.charAt(0).toUpperCase() + player.color.slice(1)} has no moves available`);
                    
                    if (roll===6){
                        game.consecutiveSixes++;
                        if (game.consecutiveSixes>=3){
                            updateStatusMessage(`${player.color.charAt(0).toUpperCase() + player.color.slice(1)} rolled three 6s in a row! Turn lost.`);
                            game.consecutiveSixes = 0;
                            nextPlayer();
                            return;
                        }
                        
                        if (player.isAI){
                            await sleep(800);
                            await playerTurn();
                            return;
                        } else {
                            // For human player, highlight would happen here if we had manual selection
                            nextPlayer();
                            return;
                        }
                    }
                    
                    nextPlayer();
                    return;
                }

                // Choose token to move
                let chosen;
                if (isAI) {
                    chosen = chooseTokenToMove(player.color, roll) || movable[0];
                    await sleep(800); // AI "thinking" time
                    game.selectedToken = chosen;
                    await moveSelectedToken();
                } else {
                    // For human players, highlight movable tokens and wait for selection
                    highlightMovableTokens(player, roll);
                    game.waitingForTokenSelection = true;
                    updateStatusMessage(`${player.color.charAt(0).toUpperCase() + player.color.slice(1)}, select a token to move!`);
                    
                    // Wait for token selection
                    return new Promise((resolve) => {
                        const checkSelection = setInterval(() => {
                            if (!game.waitingForTokenSelection && game.selectedToken) {
                                clearInterval(checkSelection);
                                moveSelectedToken().then(resolve);
                            }
                        }, 100);
                    });
                }
            }

            // Event listeners
            diceEl.addEventListener('click', async ()=>{
                if (game.diceRolling || !game.gameActive) return;
                
                const player = game.players[game.currentPlayerIdx];
                if (player.isAI) return;
                
                await playerTurn();
            });

            // Start new game
            async function initGame(){
                // Reset achievements
                achievements = {
                    firstWin: false,
                    threeSixes: false,
                    perfectGame: false,
                    comeback: false
                };
                
                // Get AI settings from switches
                game.players[0].isAI = document.getElementById('redAI').checked;
                game.players[1].isAI = document.getElementById('greenAI').checked;
                game.players[2].isAI = document.getElementById('blueAI').checked;
                game.players[3].isAI = document.getElementById('yellowAI').checked;
                
                // Remove old token elements
                for (const t of Object.values(game.tokens||{})){
                    if (t.element && t.element.remove) t.element.remove();
                }
                
                // Reset game state
                game.currentPlayerIdx = 0; 
                game.consecutiveSixes=0; 
                game.lastRoll=null; 
                game.winnerOrder=[];
                game.gameActive = true;
                game.waitingForTokenSelection = false;
                game.selectedToken = null;
                game.gameHistory = [];
                game.stats = {
                    rolls: {red:0, green:0, blue:0, yellow:0},
                    moves: {red:0, green:0, blue:0, yellow:0},
                    captures: {red:0, green:0, blue:0, yellow:0},
                    sixes: {red:0, green:0, blue:0, yellow:0}
                };
                
                // Update UI
                document.getElementById('modeLabel').innerText = game.players.some(p=>p.isAI) ? 'Local + AI' : 'Local (All human)';
                createTokens();
                updatePlayersUI(); 
                updateTurnDisplay();
                updateStatusMessage("Game started! " + game.players[0].color.charAt(0).toUpperCase() + 
                    game.players[0].color.slice(1) + " goes first.");
                winnerList.style.display = 'none';
                statsContainer.style.display = 'none';
                historyContainer.style.display = 'none';
                
                // Show initial turn transition
                await showTurnTransition(game.players[0]);
                
                // Place tokens correctly once board layout is stable
                setTimeout(()=>{ 
                    for (const t of Object.values(game.tokens)) {
                        // Get the correct home position for each token
                        const color = t.color;
                        const tokenId = t.id;
                        const tokenNum = parseInt(tokenId.split('_')[1].slice(1));
                        const homePositions = {
                            red: [
                                {r:3,c:3}, {r:3,c:4}, 
                                {r:4,c:3}, {r:4,c:4}
                            ],
                            green: [
                                {r:3,c:12}, {r:3,c:13}, 
                                {r:4,c:12}, {r:4,c:13}
                            ],
                            blue: [
                                {r:12,c:3}, {r:12,c:4}, 
                                {r:13,c:3}, {r:13,c:4}
                            ],
                            yellow: [
                                {r:12,c:12}, {r:12,c:13}, 
                                {r:13,c:12}, {r:13,c:13}
                            ]
                        };
                        const homeCoord = homePositions[color][tokenNum];
                        placeTokenElement(t, homeCoord);
                    }
                }, 200);
            }

            document.getElementById('startBtn').addEventListener('click', initGame);

            document.getElementById('toggleAiBtn').addEventListener('click', ()=>{
                const allAI = game.players.every(p => p.isAI);
                game.players.forEach(p => p.isAI = !allAI);
                
                // Update switches to match
                document.getElementById('redAI').checked = game.players[0].isAI;
                document.getElementById('greenAI').checked = game.players[1].isAI;
                document.getElementById('blueAI').checked = game.players[2].isAI;
                document.getElementById('yellowAI').checked = game.players[3].isAI;
                
                document.getElementById('modeLabel').innerText = game.players.some(p=>p.isAI) ? 'Local + AI' : 'Local (All human)';
                updatePlayersUI();
            });

            // Stats button
            document.getElementById('statsBtn').addEventListener('click', () => {
                updateStatsDisplay();
                statsContainer.style.display = statsContainer.style.display === 'none' ? 'block' : 'none';
                historyContainer.style.display = 'none';
            });

            // Close stats
            document.getElementById('closeStats').addEventListener('click', () => {
                statsContainer.style.display = 'none';
            });

            // Show history
            document.getElementById('closeHistory').addEventListener('click', () => {
                historyContainer.style.display = 'none';
            });

            // Individual AI toggles
            document.getElementById('redAI').addEventListener('change', (e) => {
                game.players[0].isAI = e.target.checked;
                updatePlayersUI();
            });
            
            document.getElementById('greenAI').addEventListener('change', (e) => {
                game.players[1].isAI = e.target.checked;
                updatePlayersUI();
            });
            
            document.getElementById('blueAI').addEventListener('change', (e) => {
                game.players[2].isAI = e.target.checked;
                updatePlayersUI();
            });
            
            document.getElementById('yellowAI').addEventListener('change', (e) => {
                game.players[3].isAI = e.target.checked;
                updatePlayersUI();
            });

            // NEW: Game speed controls
            document.querySelectorAll('.speed-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    // Remove active class from all buttons
                    document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
                    
                    // Add active class to clicked button
                    this.classList.add('active');
                    
                    // Set game speed based on button
                    const speed = this.getAttribute('data-speed');
                    switch(speed) {
                        case 'slow':
                            gameSpeed = 500;
                            break;
                        case 'normal':
                            gameSpeed = 300;
                            break;
                        case 'fast':
                            gameSpeed = 150;
                            break;
                    }
                });
            });

            // Auto-play loop for AI players
            async function autoplayerLoop(){
                while (true){
                    await sleep(500);
                    if (game.gameActive) {
                        const player = game.players[game.currentPlayerIdx];
                        if (player.isAI){
                            await playerTurn();
                        }
                    }
                }
            }

            // Bot typing function
            function typeMessage(message, messageDiv, callback) {
                let index = 0;
                messageDiv.innerHTML = '';
                
                const typingInterval = setInterval(() => {
                    if (index < message.length) {
                        messageDiv.innerHTML += message.charAt(index);
                        index++;
                        
                        // Scroll to bottom of messages
                        const messages = document.querySelector('.bot-messages');
                        messages.scrollTop = messages.scrollHeight;
                    } else {
                        clearInterval(typingInterval);
                        if (callback) callback();
                    }
                }, 30); // Adjust typing speed here (milliseconds per character)
            }

            // Bot Assistant Functionality
            document.getElementById('botToggle').addEventListener('click', function() {
                document.getElementById('botAssistant').classList.toggle('active');
            });
            
            document.getElementById('botClose').addEventListener('click', function() {
                document.getElementById('botAssistant').classList.remove('active');
            });
            
            // Bot Questions
            document.querySelectorAll('.bot-question').forEach(button => {
                button.addEventListener('click', function() {
                    const question = this.getAttribute('data-question');
                    const messages = document.querySelector('.bot-messages');
                    
                    let response = '';
                    switch(question) {
                        case 'ludo-rules':
                            response = 'Ludo is played with 2-4 players. Each player has 4 tokens. Roll a 6 to move a token out of home. Move tokens around the board clockwise. Land on an opponent\'s token to send it back home. Reach the center to win.';
                            break;
                        case 'ludo-strategy':
                            response = 'Good strategies include: 1) Prioritize getting tokens out of home, 2) Block opponents by placing multiple tokens together, 3) Use safe squares to avoid being captured, 4) Try to capture opponent tokens when possible, 5) Spread your tokens to increase movement options.';
                            break;
                        case 'ludo-tokens':
                            response = 'Each player has 4 tokens. They start in their colored home area. When a token reaches the center, it is finished. The first player to get all 4 tokens to the center wins the game. Tokens can be captured by opponents and sent back to home.';
                            break;
                    }
                    
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'bot-message';
                    messages.appendChild(messageDiv);
                    
                    // Show typing indicator
                    const typingIndicator = document.createElement('div');
                    typingIndicator.className = 'bot-message';
                    typingIndicator.innerHTML = '<p>MO11 is typing<span class="typing-cursor"></span></p>';
                    messages.appendChild(typingIndicator);
                    messages.scrollTop = messages.scrollHeight;
                    
                    // Remove typing indicator and type the actual message
                    setTimeout(() => {
                        messages.removeChild(typingIndicator);
                        typeMessage(response, messageDiv);
                    }, 1000);
                });
            });

            // Navigation buttons
            document.getElementById('btnBack').addEventListener('click', function() {
                if (confirm('Are you sure you want to go back to games menu?')) {
                    window.location.href = 'games.html';
                }
            });
            
            document.getElementById('btnExit').addEventListener('click', function() {
                if (confirm('Are you sure you want to exit GameNest?')) {
                    window.location.href = 'index.html';
                }
            });

            // Music Toggle Functionality
            const musicToggle = document.getElementById('musicToggle');
            
            // Auto-play background music on page load
            window.addEventListener('load', function() {
                // Try to play background music automatically
                const playPromise = backgroundMusic.play();
                
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        // Auto-play started successfully
                        musicToggle.classList.add('playing');
                    }).catch(error => {
                        // Auto-play was prevented, show the play button
                        console.log("Auto-play prevented:", error);
                        musicToggle.classList.remove('playing');
                    });
                }
            });
            
            musicToggle.addEventListener('click', function() {
                if (backgroundMusic.paused) {
                    backgroundMusic.play();
                    musicToggle.classList.add('playing');
                } else {
                    backgroundMusic.pause();
                    musicToggle.classList.remove('playing');
                }
            });

            // Initialize UI but don't start the game
            // Initialize UI but don't start the game
            function initializeUI() {
                // Get AI settings from switches
                game.players[0].isAI = document.getElementById('redAI').checked;
                game.players[1].isAI = document.getElementById('greenAI').checked;
                game.players[2].isAI = document.getElementById('blueAI').checked;
                game.players[3].isAI = document.getElementById('yellowAI').checked;
                
                // Remove old token elements
                for (const t of Object.values(game.tokens||{})){
                    if (t.element && t.element.remove) t.element.remove();
                }
                
                // Reset game state
                game.currentPlayerIdx = 0; 
                game.consecutiveSixes=0; 
                game.lastRoll=null; 
                game.winnerOrder=[];
                game.gameActive = false;
                game.waitingForTokenSelection = false;
                game.selectedToken = null;
                game.gameHistory = [];
                game.stats = {
                    rolls: {red:0, green:0, blue:0, yellow:0},
                    moves: {red:0, green:0, blue:0, yellow:0},
                    captures: {red:0, green:0, blue:0, yellow:0},
                    sixes: {red:0, green:0, blue:0, yellow:0}
                };
                
                // Update UI
                document.getElementById('modeLabel').innerText = game.players.some(p=>p.isAI) ? 'Local + AI' : 'Local (All human)';
                createTokens();
                updatePlayersUI(); 
                updateTurnDisplay();
                updateStatusMessage("Click 'New Game' to start playing!");
                winnerList.style.display = 'none';
                statsContainer.style.display = 'none';
                historyContainer.style.display = 'none';
                
                // Place tokens correctly once board layout is stable
                setTimeout(()=>{ 
                    for (const t of Object.values(game.tokens)) {
                        // Get the correct home position for each token
                        const color = t.color;
                        const tokenId = t.id;
                        const tokenNum = parseInt(tokenId.split('_')[1].slice(1));
                        const homePositions = {
                            red: [
                                {r:3,c:3}, {r:3,c:4}, 
                                {r:4,c:3}, {r:4,c:4}
                            ],
                            green: [
                                {r:3,c:12}, {r:3,c:13}, 
                                {r:4,c:12}, {r:4,c:13}
                            ],
                            blue: [
                                {r:12,c:3}, {r:12,c:4}, 
                                {r:13,c:3}, {r:13,c:4}
                            ],
                            yellow: [
                                {r:12,c:12}, {r:12,c:13}, 
                                {r:13,c:12}, {r:13,c:13}
                            ]
                        };
                        const homeCoord = homePositions[color][tokenNum];
                        placeTokenElement(t, homeCoord);
                    }
                }, 200);
            }

            // Initialize the UI when page loads
            initializeUI();
            // Don't start the autoplayer loop until the game is started
            // autoplayerLoop();
 
            // Expose for debugging
            window.game = game;
        });
    </script>
</body>
</html>